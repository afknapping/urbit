/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is not neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./dist/browser.js":
/*!*************************!*\
  !*** ./dist/browser.js ***!
  \*************************/
/*! unknown exports (runtime-defined) */
/*! runtime requirements: module */
/*! CommonJS bailout: module.exports is used directly at 2:65-79 */
/***/ ((module) => {

eval("(function webpackUniversalModuleDefinition(root, factory) {\n  if (true) module.exports = factory();else {}\n})(self, function () {\n  return (\n    /******/\n    (() => {\n      // webpackBootstrap\n\n      /******/\n      var __webpack_modules__ = {\n        /***/\n        328:\n        /***/\n        (__unused_webpack_module, __webpack_exports__, __nested_webpack_require_556__) => {\n          \"use strict\"; // EXPORTS\n\n          __nested_webpack_require_556__.d(__webpack_exports__, {\n            \"default\": () =>\n            /* reexport */\n            Urbit\n          }); // UNUSED EXPORTS: ChatHook\n          // EXTERNAL MODULE: ./node_modules/browser-or-node/lib/index.js\n\n\n          var lib = __nested_webpack_require_556__(818); // EXTERNAL MODULE: ./node_modules/stream-http/index.js\n\n\n          var stream_http = __nested_webpack_require_556__(501); // CONCATENATED MODULE: ./src/utils.ts\n\n\n          ;\n\n          function request(url, options, body) {\n            return new Promise((resolve, reject) => {\n              const req = http.request(url, options, res => {\n                let data = \"\";\n                res.on(\"data\", chunk => {\n                  data += chunk;\n                });\n                res.on(\"end\", () => {\n                  resolve({\n                    req,\n                    res,\n                    data\n                  });\n                });\n                res.on(\"error\", e => {\n                  reject(e);\n                });\n              });\n\n              if (body) {\n                req.write(body);\n              }\n\n              req.end();\n            });\n          }\n\n          function camelize(str) {\n            return str.replace(/\\s(.)/g, function ($1) {\n              return $1.toUpperCase();\n            }).replace(/\\s/g, '').replace(/^(.)/, function ($1) {\n              return $1.toLowerCase();\n            });\n          }\n\n          function uncamelize(str, separator = '-') {\n            // Replace all capital letters by separator followed by lowercase one\n            var str = str.replace(/[A-Z]/g, function (letter) {\n              return separator + letter.toLowerCase();\n            });\n            return str.replace(new RegExp('^' + separator), '');\n          }\n          /**\n           * Returns a hex string of given length.\n           *\n           * Poached from StackOverflow.\n           *\n           * @param len Length of hex string to return.\n           */\n\n\n          function hexString(len) {\n            const maxlen = 8;\n            const min = Math.pow(16, Math.min(len, maxlen) - 1);\n            const max = Math.pow(16, Math.min(len, maxlen)) - 1;\n            const n = Math.floor(Math.random() * (max - min + 1)) + min;\n            let r = n.toString(16);\n\n            while (r.length < len) {\n              r = r + hexString(len - maxlen);\n            }\n\n            return r;\n          }\n          /**\n           * Generates a random UID.\n           *\n           * Copied from https://github.com/urbit/urbit/blob/137e4428f617c13f28ed31e520eff98d251ed3e9/pkg/interface/src/lib/util.js#L3\n           */\n\n\n          function uid() {\n            let str = '0v';\n            str += Math.ceil(Math.random() * 8) + '.';\n\n            for (let i = 0; i < 5; i++) {\n              let _str = Math.ceil(Math.random() * 10000000).toString(32);\n\n              _str = ('00000' + _str).substr(-5, 5);\n              str += _str + '.';\n            }\n\n            return str.slice(0, -1);\n          } // CONCATENATED MODULE: ./src/urbit.ts\n\n\n          function ownKeys(object, enumerableOnly) {\n            var keys = Object.keys(object);\n\n            if (Object.getOwnPropertySymbols) {\n              var symbols = Object.getOwnPropertySymbols(object);\n              if (enumerableOnly) symbols = symbols.filter(function (sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n              });\n              keys.push.apply(keys, symbols);\n            }\n\n            return keys;\n          }\n\n          function _objectSpread(target) {\n            for (var i = 1; i < arguments.length; i++) {\n              var source = arguments[i] != null ? arguments[i] : {};\n\n              if (i % 2) {\n                ownKeys(Object(source), true).forEach(function (key) {\n                  _defineProperty(target, key, source[key]);\n                });\n              } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n              } else {\n                ownKeys(Object(source)).forEach(function (key) {\n                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                });\n              }\n            }\n\n            return target;\n          }\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n          /**\n           * A class for interacting with an urbit ship, given its URL and code\n           */\n\n\n          class Urbit {\n            /**\n             * UID will be used for the channel: The current unix time plus a random hex string\n             */\n\n            /**\n             * Last Event ID is an auto-updated index of which events have been sent over this channel\n             */\n\n            /**\n             * SSE Client is null for now; we don't want to start polling until it the channel exists\n             */\n\n            /**\n             * Cookie gets set when we log in.\n             */\n\n            /**\n             * A registry of requestId to successFunc/failureFunc\n             * \n             * These functions are registered during a +poke and are executed\n             * in the onServerEvent()/onServerError() callbacks. Only one of\n             * the functions will be called, and the outstanding poke will be\n             * removed after calling the success or failure function.\n             */\n\n            /**\n             * A registry of requestId to subscription functions.\n             * \n             * These functions are registered during a +subscribe and are\n             * executed in the onServerEvent()/onServerError() callbacks. The\n             * event function will be called whenever a new piece of data on this\n             * subscription is available, which may be 0, 1, or many times. The\n             * disconnect function may be called exactly once.\n             */\n\n            /**\n             * Ship can be set, in which case we can do some magic stuff like send chats\n             */\n\n            /**\n             * If verbose, logs output eagerly.\n             */\n\n            /**\n             * All registered apps, keyed by name\n             */\n\n            /** This is basic interpolation to get the channel URL of an instantiated Urbit connection. */\n            get channelUrl() {\n              return `${this.url}/~/channel/${this.uid}`;\n            }\n\n            get fetchOptions() {\n              const headers = {\n                'Content-Type': 'application/json'\n              };\n\n              if (!lib\n              /* isBrowser */\n              .jU) {\n                headers.Cookie = this.cookie;\n              }\n\n              return {\n                credentials: 'include',\n                headers\n              };\n            }\n            /**\n             * Constructs a new Urbit connection.\n             *\n             * @param url  The URL (with protocol and port) of the ship to be accessed\n             * @param code The access code for the ship at that address\n             */\n\n\n            constructor(url, code) {\n              this.url = url;\n              this.code = code;\n\n              _defineProperty(this, \"uid\", `${Math.floor(Date.now() / 1000)}-${hexString(6)}`);\n\n              _defineProperty(this, \"lastEventId\", 0);\n\n              _defineProperty(this, \"lastAcknowledgedEventId\", 0);\n\n              _defineProperty(this, \"sseClient\", null);\n\n              _defineProperty(this, \"cookie\", void 0);\n\n              _defineProperty(this, \"outstandingPokes\", new Map());\n\n              _defineProperty(this, \"outstandingSubscriptions\", new Map());\n\n              _defineProperty(this, \"ship\", void 0);\n\n              _defineProperty(this, \"verbose\", void 0); // We return a proxy so we can set dynamic properties like `Urbit.onChatHook`\n\n\n              return new Proxy(this, {\n                get(target, property) {\n                  // First check if this is a regular property\n                  if (property in target) {\n                    return target[property];\n                  } // Then check if it's a registered app\n\n\n                  const app = Urbit.apps.get(uncamelize(property));\n\n                  if (app) {\n                    return new app(target);\n                  } // Then check to see if we're trying to register an EventSource watcher\n\n\n                  if (property.startsWith('on')) {\n                    const on = uncamelize(property.replace('on', '')).toLowerCase();\n                    return action => {\n                      target.eventSource().addEventListener('message', event => {\n                        if (target.verbose) {\n                          console.log(`Received SSE from ${on}: `, event);\n                        }\n\n                        if (event.data && JSON.parse(event.data)) {\n                          const data = JSON.parse(event.data);\n\n                          if (data.json.hasOwnProperty(on)) {\n                            action(data.json[on], data.json.response);\n                          }\n                        }\n                      });\n                    };\n                  }\n\n                  return undefined;\n                }\n\n              });\n            }\n            /**\n             * All-in-one hook-me-up.\n             * \n             * Given a ship, url, and code, this returns an airlock connection\n             * that is ready to go. It `|hi`s itself to create the channel,\n             * then opens the channel via EventSource.\n             * \n             * @param AuthenticationInterface\n             */\n\n\n            static async authenticate({\n              ship,\n              url,\n              code,\n              verbose = false\n            }) {\n              const airlock = new Urbit(`http://${url}`, code);\n              airlock.verbose = verbose;\n              airlock.ship = ship;\n              await airlock.connect();\n              await airlock.poke('hood', 'helm-hi', 'opening airlock');\n              await airlock.eventSource();\n              return airlock;\n            }\n            /**\n             * Connects to the Urbit ship. Nothing can be done until this is called.\n             * That's why we roll it into this.authenticate\n             */\n\n\n            async connect() {\n              if (this.verbose) {\n                console.log(`password=${this.code} `, lib\n                /* isBrowser */\n                .jU ? \"Connecting in browser context at \" + `${this.url}/~/login` : \"Connecting from node context\");\n              }\n\n              return fetch(`${this.url}/~/login`, {\n                method: 'post',\n                body: `password=${this.code}`,\n                credentials: 'include'\n              }).then(response => {\n                if (this.verbose) {\n                  console.log('Received authentication response', response);\n                }\n\n                const cookie = response.headers.get('set-cookie');\n\n                if (!this.ship) {\n                  this.ship = new RegExp(/urbauth-~([\\w-]+)/).exec(cookie)[1];\n                }\n\n                if (!lib\n                /* isBrowser */\n                .jU) {\n                  this.cookie = cookie;\n                }\n              }).catch(error => {\n                console.log(XMLHttpRequest);\n                console.log('errored');\n                console.log(error);\n              });\n            }\n            /**\n             * Returns (and initializes, if necessary) the SSE pipe for the appropriate channel.\n             */\n\n\n            eventSource() {\n              if (!this.sseClient) {\n                const sseOptions = {\n                  headers: {}\n                };\n\n                if (lib\n                /* isBrowser */\n                .jU) {\n                  sseOptions.withCredentials = true;\n                } else if (lib\n                /* isNode */\n                .UG) {\n                  sseOptions.headers.Cookie = this.cookie;\n                }\n\n                this.sseClient = new EventSource(this.channelUrl, sseOptions);\n                this.sseClient.addEventListener('message', event => {\n                  if (this.verbose) {\n                    console.log('Received SSE: ', event);\n                  }\n\n                  this.ack(Number(event.lastEventId));\n\n                  if (event.data && JSON.parse(event.data)) {\n                    const data = JSON.parse(event.data);\n\n                    if (data.response === 'poke' && this.outstandingPokes.has(data.id)) {\n                      const funcs = this.outstandingPokes.get(data.id);\n\n                      if (data.hasOwnProperty('ok')) {\n                        funcs.success();\n                      } else if (data.hasOwnProperty('err')) {\n                        funcs.fail(data.err);\n                      } else {\n                        console.error('Invalid poke response', data);\n                      }\n\n                      this.outstandingPokes.delete(data.id);\n                    } else if (data.response === 'subscribe' || data.response === 'poke' && this.outstandingSubscriptions.has(data.id)) {\n                      const funcs = this.outstandingSubscriptions.get(data.id);\n\n                      if (data.hasOwnProperty('err')) {\n                        funcs.err(data.err);\n                        this.outstandingSubscriptions.delete(data.id);\n                      }\n                    } else if (data.response === 'diff' && this.outstandingSubscriptions.has(data.id)) {\n                      const funcs = this.outstandingSubscriptions.get(data.id);\n                      funcs.event(data.json);\n                    } else if (data.response === 'quit' && this.outstandingSubscriptions.has(data.id)) {\n                      const funcs = this.outstandingSubscriptions.get(data.id);\n                      funcs.quit(data);\n                      this.outstandingSubscriptions.delete(data.id);\n                    } else {\n                      console.log('Unrecognized response', data);\n                    } // An incoming message, for example:\n                    // {\n                    //   id: 10,\n                    //   json: {\n                    //     'chat-update' : { // This is where we hook our \"on\" handlers like \"onChatUpdate\"\n                    //       message: {\n                    //         envelope: {\n                    //           author: 'zod',\n                    //           letter: {\n                    //             text: 'hi'\n                    //           },\n                    //           number: 10,\n                    //           uid: 'saludhafhsdf',\n                    //           when: 124459\n                    //         },\n                    //         path: '/~zod/mailbox'\n                    //       }\n                    //     }\n                    //   }\n                    // }\n\n                  }\n                });\n                this.sseClient.addEventListener('error', function (event) {\n                  console.error('pipe error', event);\n                });\n              }\n\n              return this.sseClient;\n            }\n            /**\n             * Autoincrements the next event ID for the appropriate channel.\n             */\n\n\n            getEventId() {\n              this.lastEventId = Number(this.lastEventId) + 1;\n              return this.lastEventId;\n            }\n            /**\n             * Acknowledges an event.\n             *\n             * @param eventId The event to acknowledge.\n             */\n\n\n            ack(eventId) {\n              return this.sendMessage('ack', {\n                'event-id': eventId\n              });\n            }\n            /**\n             * This is a wrapper method that can be used to send any action with data.\n             *\n             * Every message sent has some common parameters, like method, headers, and data\n             * structure, so this method exists to prevent duplication.\n             *\n             * @param action The action to send\n             * @param data The data to send with the action\n             * \n             * @returns void | number If successful, returns the number of the message that was sent\n             */\n\n\n            sendMessage(action, data) {\n              const id = this.getEventId();\n\n              if (this.verbose) {\n                console.log(`Sending message ${id}:`, action, data);\n              }\n\n              return fetch(this.channelUrl, _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                method: 'put',\n                body: JSON.stringify([_objectSpread({\n                  id,\n                  action\n                }, data)])\n              })).catch(error => {\n                console.error('message error', error);\n              }).then(response => {\n                if (this.verbose) {\n                  console.log(`Received from message ${id}: `, response);\n                }\n\n                return id;\n              });\n            }\n            /**\n             * Pokes a ship with data.\n             *\n             * @param app The app to poke\n             * @param mark The mark of the data being sent\n             * @param json The data to send\n             */\n\n\n            poke(app, mark, json, successFunc = () => {}, failureFunc = () => {}) {\n              return new Promise((resolve, reject) => {\n                this.sendMessage('poke', {\n                  ship: this.ship,\n                  app,\n                  mark,\n                  json\n                }).then(pokeId => {\n                  if (!pokeId) {\n                    return reject('Poke failed');\n                  }\n\n                  this.outstandingPokes.set(pokeId, {\n                    success: () => {\n                      successFunc();\n                      resolve(pokeId);\n                    },\n                    fail: event => {\n                      failureFunc();\n                      reject(event.err);\n                    }\n                  });\n                });\n              });\n            }\n            /**\n             * Subscribes to a path on an app on a ship.\n             *\n             * @param app The app to subsribe to\n             * @param path The path to which to subscribe\n             * @param handlers Handlers to deal with various events of the subscription\n             */\n\n\n            async subscribe(app, path, handlers) {\n              const {\n                err,\n                event,\n                quit\n              } = _objectSpread({\n                err: () => {},\n                event: () => {},\n                quit: () => {}\n              }, handlers);\n\n              const subscriptionId = await this.sendMessage('subscribe', {\n                ship: this.ship,\n                app,\n                path\n              });\n              if (!subscriptionId) return;\n              this.outstandingSubscriptions.set(subscriptionId, {\n                err,\n                event,\n                quit\n              });\n              return subscriptionId;\n            }\n            /**\n             * Unsubscribes to a given subscription.\n             *\n             * @param subscription\n             */\n\n\n            unsubscribe(subscription) {\n              return this.sendMessage('unsubscribe', {\n                subscription\n              });\n            }\n            /**\n             * Deletes the connection to a channel.\n             */\n\n\n            delete() {\n              return this.sendMessage('delete');\n            }\n            /**\n             * \n             * @param app   The app into which to scry\n             * @param path  The path at which to scry\n             */\n\n\n            scry(app, path) {\n              return fetch(`/~/scry/${app}${path}.json`, this.fetchOptions).then(response => response.json());\n            }\n            /**\n             * \n             * @param inputMark   The mark of the data being sent\n             * @param outputMark  The mark of the data being returned\n             * @param threadName  The thread to run\n             * @param body        The data to send to the thread\n             */\n\n\n            async spider(inputMark, outputMark, threadName, body) {\n              const res = await fetch(`/spider/${inputMark}/${threadName}/${outputMark}.json`, _objectSpread(_objectSpread({}, this.fetchOptions), {}, {\n                method: 'POST',\n                body: JSON.stringify(body)\n              }));\n              return res.json();\n            }\n\n            app(appName) {\n              const appClass = Urbit.apps.get(appName);\n\n              if (!appClass) {\n                throw new Error(`App ${appName} not found`);\n              }\n\n              return new appClass(this);\n            }\n            /**\n             * Utility function to connect to a ship that has its *.arvo.network domain configured.\n             *\n             * @param name Name of the ship e.g. zod\n             * @param code Code to log in\n             */\n\n\n            static async onArvoNetwork(ship, code) {\n              const url = `https://${name}.arvo.network`;\n              return await Urbit.authenticate({\n                ship,\n                url,\n                code\n              });\n            }\n\n            static extend(appClass) {\n              Urbit.apps.set(appClass.app, appClass);\n            }\n\n          }\n\n          _defineProperty(Urbit, \"apps\", new Map()); // CONCATENATED MODULE: ./src/app/base.ts\n\n\n          function base_defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          class UrbitApp {\n            get app() {\n              throw new Error('Access app property on base UrbitApp');\n            }\n\n            constructor(airlock) {\n              base_defineProperty(this, \"airlock\", void 0);\n              this.airlock = airlock;\n            }\n            /**\n             * Getter that barfs if no ship has been passed\n             */\n\n\n            get ship() {\n              if (!this.airlock.ship) {\n                throw new Error('No ship specified');\n              }\n\n              return this.airlock.ship;\n            }\n            /**\n             * Helper to allow any app to handle subscriptions.\n             * \n             * @param path Path on app to subscribe to\n             */\n\n\n            subscribe(path) {\n              const ship = this.ship;\n              const app = this.app;\n              return this.airlock.subscribe(app, path);\n            } // TODO handle methods that don't exist\n\n\n          } // CONCATENATED MODULE: ./src/app/chat-hook.ts\n\n\n          ; // This class exists an example of how to create an app that extends\n          // the core Urbit library.\n\n          class ChatHook extends UrbitApp {\n            get app() {\n              return 'chat-hook';\n            }\n\n            message(message) {\n              return this.airlock.poke(this.app, 'json', {\n                message: {\n                  path: message.path,\n                  envelope: {\n                    uid: uid(),\n                    number: 1,\n                    // Dummy, gets overwritten\n                    author: message.ship || `~${this.ship}`,\n                    when: new Date().getTime(),\n                    letter: {\n                      text: message.text // TODO other types\n\n                    }\n                  }\n                }\n              });\n            }\n\n          }\n\n          Urbit.extend(ChatHook);\n          /* harmony default export */\n\n          const chat_hook =\n          /* unused pure expression or super */\n          null && 0; // CONCATENATED MODULE: ./src/index.ts\n\n          ;\n          /***/\n        },\n\n        /***/\n        742:\n        /***/\n        (__unused_webpack_module, exports) => {\n          \"use strict\";\n\n          exports.byteLength = byteLength;\n          exports.toByteArray = toByteArray;\n          exports.fromByteArray = fromByteArray;\n          const lookup = [];\n          const revLookup = [];\n          const Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;\n          const code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n          for (let i = 0, len = code.length; i < len; ++i) {\n            lookup[i] = code[i];\n            revLookup[code.charCodeAt(i)] = i;\n          } // Support decoding URL-safe base64 strings, as Node.js does.\n          // See: https://en.wikipedia.org/wiki/Base64#URL_applications\n\n\n          revLookup['-'.charCodeAt(0)] = 62;\n          revLookup['_'.charCodeAt(0)] = 63;\n\n          function getLens(b64) {\n            const len = b64.length;\n\n            if (len % 4 > 0) {\n              throw new Error('Invalid string. Length must be a multiple of 4');\n            } // Trim off extra bytes after placeholder bytes are found\n            // See: https://github.com/beatgammit/base64-js/issues/42\n\n\n            let validLen = b64.indexOf('=');\n            if (validLen === -1) validLen = len;\n            const placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;\n            return [validLen, placeHoldersLen];\n          } // base64 is 4/3 + up to two characters of the original data\n\n\n          function byteLength(b64) {\n            const lens = getLens(b64);\n            const validLen = lens[0];\n            const placeHoldersLen = lens[1];\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n\n          function _byteLength(b64, validLen, placeHoldersLen) {\n            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n          }\n\n          function toByteArray(b64) {\n            let tmp;\n            const lens = getLens(b64);\n            const validLen = lens[0];\n            const placeHoldersLen = lens[1];\n            const arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n            let curByte = 0; // if there are placeholders, only get up to the last complete 4 chars\n\n            const len = placeHoldersLen > 0 ? validLen - 4 : validLen;\n            let i;\n\n            for (i = 0; i < len; i += 4) {\n              tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];\n              arr[curByte++] = tmp >> 16 & 0xFF;\n              arr[curByte++] = tmp >> 8 & 0xFF;\n              arr[curByte++] = tmp & 0xFF;\n            }\n\n            if (placeHoldersLen === 2) {\n              tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;\n              arr[curByte++] = tmp & 0xFF;\n            }\n\n            if (placeHoldersLen === 1) {\n              tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;\n              arr[curByte++] = tmp >> 8 & 0xFF;\n              arr[curByte++] = tmp & 0xFF;\n            }\n\n            return arr;\n          }\n\n          function tripletToBase64(num) {\n            return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];\n          }\n\n          function encodeChunk(uint8, start, end) {\n            let tmp;\n            const output = [];\n\n            for (let i = start; i < end; i += 3) {\n              tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);\n              output.push(tripletToBase64(tmp));\n            }\n\n            return output.join('');\n          }\n\n          function fromByteArray(uint8) {\n            let tmp;\n            const len = uint8.length;\n            const extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes\n\n            const parts = [];\n            const maxChunkLength = 16383; // must be multiple of 3\n            // go through the array every three bytes, we'll deal with trailing stuff later\n\n            for (let i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n              parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));\n            } // pad the end with zeros, but make sure to not forget the extra bytes\n\n\n            if (extraBytes === 1) {\n              tmp = uint8[len - 1];\n              parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');\n            } else if (extraBytes === 2) {\n              tmp = (uint8[len - 2] << 8) + uint8[len - 1];\n              parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');\n            }\n\n            return parts.join('');\n          }\n          /***/\n\n        },\n\n        /***/\n        818:\n        /***/\n        (__unused_webpack_module, exports) => {\n          \"use strict\";\n\n          var __webpack_unused_export__;\n\n          __webpack_unused_export__ = {\n            value: true\n          };\n\n          var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n            return typeof obj;\n          } : function (obj) {\n            return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n          };\n          /* global window self */\n\n\n          var isBrowser = typeof window !== 'undefined' && typeof window.document !== 'undefined';\n          /* eslint-disable no-restricted-globals */\n\n          var isWebWorker = (typeof self === 'undefined' ? 'undefined' : _typeof(self)) === 'object' && self.constructor && self.constructor.name === 'DedicatedWorkerGlobalScope';\n          /* eslint-enable no-restricted-globals */\n\n          var isNode = typeof process !== 'undefined' && process.versions != null && process.versions.node != null;\n          /**\n           * @see https://github.com/jsdom/jsdom/releases/tag/12.0.0\n           * @see https://github.com/jsdom/jsdom/issues/1537\n           */\n\n          /* eslint-disable no-undef */\n\n          var isJsDom = function isJsDom() {\n            return typeof window !== 'undefined' && window.name === 'nodejs' || navigator.userAgent.includes('Node.js') || navigator.userAgent.includes('jsdom');\n          };\n\n          exports.jU = isBrowser;\n          __webpack_unused_export__ = isWebWorker;\n          exports.UG = isNode;\n          __webpack_unused_export__ = isJsDom;\n          /***/\n        },\n\n        /***/\n        764:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_31567__) => {\n          \"use strict\";\n          /*!\n           * The buffer module from node.js, for the browser.\n           *\n           * @author   Feross Aboukhadijeh <https://feross.org>\n           * @license  MIT\n           */\n\n          /* eslint-disable no-proto */\n\n          var base64 = __nested_webpack_require_31567__(742);\n\n          var ieee754 = __nested_webpack_require_31567__(645);\n\n          var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' ? // eslint-disable-line dot-notation\n          Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n          : null;\n          exports.Buffer = Buffer;\n          exports.SlowBuffer = SlowBuffer;\n          exports.INSPECT_MAX_BYTES = 50;\n          var K_MAX_LENGTH = 0x7fffffff;\n          exports.kMaxLength = K_MAX_LENGTH;\n          /**\n           * If `Buffer.TYPED_ARRAY_SUPPORT`:\n           *   === true    Use Uint8Array implementation (fastest)\n           *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n           *               implementation (most compatible, even IE6)\n           *\n           * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n           * Opera 11.6+, iOS 4.2+.\n           *\n           * We report that the browser does not support typed arrays if the are not subclassable\n           * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n           * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n           * for __proto__ and has a buggy typed array implementation.\n           */\n\n          Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();\n\n          if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {\n            console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');\n          }\n\n          function typedArraySupport() {\n            // Can typed array instances can be augmented?\n            try {\n              var arr = new Uint8Array(1);\n              var proto = {\n                foo: function () {\n                  return 42;\n                }\n              };\n              Object.setPrototypeOf(proto, Uint8Array.prototype);\n              Object.setPrototypeOf(arr, proto);\n              return arr.foo() === 42;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          Object.defineProperty(Buffer.prototype, 'parent', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.buffer;\n            }\n          });\n          Object.defineProperty(Buffer.prototype, 'offset', {\n            enumerable: true,\n            get: function () {\n              if (!Buffer.isBuffer(this)) return undefined;\n              return this.byteOffset;\n            }\n          });\n\n          function createBuffer(length) {\n            if (length > K_MAX_LENGTH) {\n              throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n            } // Return an augmented `Uint8Array` instance\n\n\n            var buf = new Uint8Array(length);\n            Object.setPrototypeOf(buf, Buffer.prototype);\n            return buf;\n          }\n          /**\n           * The Buffer constructor returns instances of `Uint8Array` that have their\n           * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n           * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n           * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n           * returns a single octet.\n           *\n           * The `Uint8Array` prototype remains unmodified.\n           */\n\n\n          function Buffer(arg, encodingOrOffset, length) {\n            // Common case.\n            if (typeof arg === 'number') {\n              if (typeof encodingOrOffset === 'string') {\n                throw new TypeError('The \"string\" argument must be of type string. Received type number');\n              }\n\n              return allocUnsafe(arg);\n            }\n\n            return from(arg, encodingOrOffset, length);\n          }\n\n          Buffer.poolSize = 8192; // not used by this implementation\n\n          function from(value, encodingOrOffset, length) {\n            if (typeof value === 'string') {\n              return fromString(value, encodingOrOffset);\n            }\n\n            if (ArrayBuffer.isView(value)) {\n              return fromArrayView(value);\n            }\n\n            if (value == null) {\n              throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n            }\n\n            if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n\n            if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n              return fromArrayBuffer(value, encodingOrOffset, length);\n            }\n\n            if (typeof value === 'number') {\n              throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n            }\n\n            var valueOf = value.valueOf && value.valueOf();\n\n            if (valueOf != null && valueOf !== value) {\n              return Buffer.from(valueOf, encodingOrOffset, length);\n            }\n\n            var b = fromObject(value);\n            if (b) return b;\n\n            if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {\n              return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);\n            }\n\n            throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + typeof value);\n          }\n          /**\n           * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n           * if value is a number.\n           * Buffer.from(str[, encoding])\n           * Buffer.from(array)\n           * Buffer.from(buffer)\n           * Buffer.from(arrayBuffer[, byteOffset[, length]])\n           **/\n\n\n          Buffer.from = function (value, encodingOrOffset, length) {\n            return from(value, encodingOrOffset, length);\n          }; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n          // https://github.com/feross/buffer/pull/148\n\n\n          Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);\n          Object.setPrototypeOf(Buffer, Uint8Array);\n\n          function assertSize(size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('\"size\" argument must be of type number');\n            } else if (size < 0) {\n              throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n            }\n          }\n\n          function alloc(size, fill, encoding) {\n            assertSize(size);\n\n            if (size <= 0) {\n              return createBuffer(size);\n            }\n\n            if (fill !== undefined) {\n              // Only pay attention to encoding if it's a string. This\n              // prevents accidentally sending in a number that would\n              // be interpreted as a start offset.\n              return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n            }\n\n            return createBuffer(size);\n          }\n          /**\n           * Creates a new filled Buffer instance.\n           * alloc(size[, fill[, encoding]])\n           **/\n\n\n          Buffer.alloc = function (size, fill, encoding) {\n            return alloc(size, fill, encoding);\n          };\n\n          function allocUnsafe(size) {\n            assertSize(size);\n            return createBuffer(size < 0 ? 0 : checked(size) | 0);\n          }\n          /**\n           * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n           * */\n\n\n          Buffer.allocUnsafe = function (size) {\n            return allocUnsafe(size);\n          };\n          /**\n           * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n           */\n\n\n          Buffer.allocUnsafeSlow = function (size) {\n            return allocUnsafe(size);\n          };\n\n          function fromString(string, encoding) {\n            if (typeof encoding !== 'string' || encoding === '') {\n              encoding = 'utf8';\n            }\n\n            if (!Buffer.isEncoding(encoding)) {\n              throw new TypeError('Unknown encoding: ' + encoding);\n            }\n\n            var length = byteLength(string, encoding) | 0;\n            var buf = createBuffer(length);\n            var actual = buf.write(string, encoding);\n\n            if (actual !== length) {\n              // Writing a hex string, for example, that contains invalid characters will\n              // cause everything after the first invalid character to be ignored. (e.g.\n              // 'abxxcd' will be treated as 'ab')\n              buf = buf.slice(0, actual);\n            }\n\n            return buf;\n          }\n\n          function fromArrayLike(array) {\n            var length = array.length < 0 ? 0 : checked(array.length) | 0;\n            var buf = createBuffer(length);\n\n            for (var i = 0; i < length; i += 1) {\n              buf[i] = array[i] & 255;\n            }\n\n            return buf;\n          }\n\n          function fromArrayView(arrayView) {\n            if (isInstance(arrayView, Uint8Array)) {\n              var copy = new Uint8Array(arrayView);\n              return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n            }\n\n            return fromArrayLike(arrayView);\n          }\n\n          function fromArrayBuffer(array, byteOffset, length) {\n            if (byteOffset < 0 || array.byteLength < byteOffset) {\n              throw new RangeError('\"offset\" is outside of buffer bounds');\n            }\n\n            if (array.byteLength < byteOffset + (length || 0)) {\n              throw new RangeError('\"length\" is outside of buffer bounds');\n            }\n\n            var buf;\n\n            if (byteOffset === undefined && length === undefined) {\n              buf = new Uint8Array(array);\n            } else if (length === undefined) {\n              buf = new Uint8Array(array, byteOffset);\n            } else {\n              buf = new Uint8Array(array, byteOffset, length);\n            } // Return an augmented `Uint8Array` instance\n\n\n            Object.setPrototypeOf(buf, Buffer.prototype);\n            return buf;\n          }\n\n          function fromObject(obj) {\n            if (Buffer.isBuffer(obj)) {\n              var len = checked(obj.length) | 0;\n              var buf = createBuffer(len);\n\n              if (buf.length === 0) {\n                return buf;\n              }\n\n              obj.copy(buf, 0, 0, len);\n              return buf;\n            }\n\n            if (obj.length !== undefined) {\n              if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n                return createBuffer(0);\n              }\n\n              return fromArrayLike(obj);\n            }\n\n            if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n              return fromArrayLike(obj.data);\n            }\n          }\n\n          function checked(length) {\n            // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n            // length is NaN (which is otherwise coerced to zero.)\n            if (length >= K_MAX_LENGTH) {\n              throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');\n            }\n\n            return length | 0;\n          }\n\n          function SlowBuffer(length) {\n            if (+length != length) {\n              // eslint-disable-line eqeqeq\n              length = 0;\n            }\n\n            return Buffer.alloc(+length);\n          }\n\n          Buffer.isBuffer = function isBuffer(b) {\n            return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false\n          };\n\n          Buffer.compare = function compare(a, b) {\n            if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);\n            if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);\n\n            if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n              throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n            }\n\n            if (a === b) return 0;\n            var x = a.length;\n            var y = b.length;\n\n            for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n              if (a[i] !== b[i]) {\n                x = a[i];\n                y = b[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          };\n\n          Buffer.isEncoding = function isEncoding(encoding) {\n            switch (String(encoding).toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'latin1':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n                return true;\n\n              default:\n                return false;\n            }\n          };\n\n          Buffer.concat = function concat(list, length) {\n            if (!Array.isArray(list)) {\n              throw new TypeError('\"list\" argument must be an Array of Buffers');\n            }\n\n            if (list.length === 0) {\n              return Buffer.alloc(0);\n            }\n\n            var i;\n\n            if (length === undefined) {\n              length = 0;\n\n              for (i = 0; i < list.length; ++i) {\n                length += list[i].length;\n              }\n            }\n\n            var buffer = Buffer.allocUnsafe(length);\n            var pos = 0;\n\n            for (i = 0; i < list.length; ++i) {\n              var buf = list[i];\n\n              if (isInstance(buf, Uint8Array)) {\n                if (pos + buf.length > buffer.length) {\n                  Buffer.from(buf).copy(buffer, pos);\n                } else {\n                  Uint8Array.prototype.set.call(buffer, buf, pos);\n                }\n              } else if (!Buffer.isBuffer(buf)) {\n                throw new TypeError('\"list\" argument must be an Array of Buffers');\n              } else {\n                buf.copy(buffer, pos);\n              }\n\n              pos += buf.length;\n            }\n\n            return buffer;\n          };\n\n          function byteLength(string, encoding) {\n            if (Buffer.isBuffer(string)) {\n              return string.length;\n            }\n\n            if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n              return string.byteLength;\n            }\n\n            if (typeof string !== 'string') {\n              throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + typeof string);\n            }\n\n            var len = string.length;\n            var mustMatch = arguments.length > 2 && arguments[2] === true;\n            if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion\n\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return len;\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8ToBytes(string).length;\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return len * 2;\n\n                case 'hex':\n                  return len >>> 1;\n\n                case 'base64':\n                  return base64ToBytes(string).length;\n\n                default:\n                  if (loweredCase) {\n                    return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8\n                  }\n\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          }\n\n          Buffer.byteLength = byteLength;\n\n          function slowToString(encoding, start, end) {\n            var loweredCase = false; // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n            // property of a typed array.\n            // This behaves neither like String nor Uint8Array in that we set start/end\n            // to their upper/lower bounds if the value passed is out of range.\n            // undefined is handled specially as per ECMA-262 6th Edition,\n            // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n\n            if (start === undefined || start < 0) {\n              start = 0;\n            } // Return early if start > this.length. Done here to prevent potential uint32\n            // coercion fail below.\n\n\n            if (start > this.length) {\n              return '';\n            }\n\n            if (end === undefined || end > this.length) {\n              end = this.length;\n            }\n\n            if (end <= 0) {\n              return '';\n            } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n\n\n            end >>>= 0;\n            start >>>= 0;\n\n            if (end <= start) {\n              return '';\n            }\n\n            if (!encoding) encoding = 'utf8';\n\n            while (true) {\n              switch (encoding) {\n                case 'hex':\n                  return hexSlice(this, start, end);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Slice(this, start, end);\n\n                case 'ascii':\n                  return asciiSlice(this, start, end);\n\n                case 'latin1':\n                case 'binary':\n                  return latin1Slice(this, start, end);\n\n                case 'base64':\n                  return base64Slice(this, start, end);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return utf16leSlice(this, start, end);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = (encoding + '').toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          } // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n          // to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n          // reliably in a browserify context because there could be multiple different\n          // copies of the 'buffer' package in use. This method works even for Buffer\n          // instances that were created from another copy of the `buffer` package.\n          // See: https://github.com/feross/buffer/issues/154\n\n\n          Buffer.prototype._isBuffer = true;\n\n          function swap(b, n, m) {\n            var i = b[n];\n            b[n] = b[m];\n            b[m] = i;\n          }\n\n          Buffer.prototype.swap16 = function swap16() {\n            var len = this.length;\n\n            if (len % 2 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 16-bits');\n            }\n\n            for (var i = 0; i < len; i += 2) {\n              swap(this, i, i + 1);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap32 = function swap32() {\n            var len = this.length;\n\n            if (len % 4 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 32-bits');\n            }\n\n            for (var i = 0; i < len; i += 4) {\n              swap(this, i, i + 3);\n              swap(this, i + 1, i + 2);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.swap64 = function swap64() {\n            var len = this.length;\n\n            if (len % 8 !== 0) {\n              throw new RangeError('Buffer size must be a multiple of 64-bits');\n            }\n\n            for (var i = 0; i < len; i += 8) {\n              swap(this, i, i + 7);\n              swap(this, i + 1, i + 6);\n              swap(this, i + 2, i + 5);\n              swap(this, i + 3, i + 4);\n            }\n\n            return this;\n          };\n\n          Buffer.prototype.toString = function toString() {\n            var length = this.length;\n            if (length === 0) return '';\n            if (arguments.length === 0) return utf8Slice(this, 0, length);\n            return slowToString.apply(this, arguments);\n          };\n\n          Buffer.prototype.toLocaleString = Buffer.prototype.toString;\n\n          Buffer.prototype.equals = function equals(b) {\n            if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');\n            if (this === b) return true;\n            return Buffer.compare(this, b) === 0;\n          };\n\n          Buffer.prototype.inspect = function inspect() {\n            var str = '';\n            var max = exports.INSPECT_MAX_BYTES;\n            str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();\n            if (this.length > max) str += ' ... ';\n            return '<Buffer ' + str + '>';\n          };\n\n          if (customInspectSymbol) {\n            Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;\n          }\n\n          Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n            if (isInstance(target, Uint8Array)) {\n              target = Buffer.from(target, target.offset, target.byteLength);\n            }\n\n            if (!Buffer.isBuffer(target)) {\n              throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + typeof target);\n            }\n\n            if (start === undefined) {\n              start = 0;\n            }\n\n            if (end === undefined) {\n              end = target ? target.length : 0;\n            }\n\n            if (thisStart === undefined) {\n              thisStart = 0;\n            }\n\n            if (thisEnd === undefined) {\n              thisEnd = this.length;\n            }\n\n            if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n              throw new RangeError('out of range index');\n            }\n\n            if (thisStart >= thisEnd && start >= end) {\n              return 0;\n            }\n\n            if (thisStart >= thisEnd) {\n              return -1;\n            }\n\n            if (start >= end) {\n              return 1;\n            }\n\n            start >>>= 0;\n            end >>>= 0;\n            thisStart >>>= 0;\n            thisEnd >>>= 0;\n            if (this === target) return 0;\n            var x = thisEnd - thisStart;\n            var y = end - start;\n            var len = Math.min(x, y);\n            var thisCopy = this.slice(thisStart, thisEnd);\n            var targetCopy = target.slice(start, end);\n\n            for (var i = 0; i < len; ++i) {\n              if (thisCopy[i] !== targetCopy[i]) {\n                x = thisCopy[i];\n                y = targetCopy[i];\n                break;\n              }\n            }\n\n            if (x < y) return -1;\n            if (y < x) return 1;\n            return 0;\n          }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n          // OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n          //\n          // Arguments:\n          // - buffer - a Buffer to search\n          // - val - a string, Buffer, or number\n          // - byteOffset - an index into `buffer`; will be clamped to an int32\n          // - encoding - an optional encoding, relevant is val is a string\n          // - dir - true for indexOf, false for lastIndexOf\n\n\n          function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n            // Empty buffer means no match\n            if (buffer.length === 0) return -1; // Normalize byteOffset\n\n            if (typeof byteOffset === 'string') {\n              encoding = byteOffset;\n              byteOffset = 0;\n            } else if (byteOffset > 0x7fffffff) {\n              byteOffset = 0x7fffffff;\n            } else if (byteOffset < -0x80000000) {\n              byteOffset = -0x80000000;\n            }\n\n            byteOffset = +byteOffset; // Coerce to Number.\n\n            if (numberIsNaN(byteOffset)) {\n              // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n              byteOffset = dir ? 0 : buffer.length - 1;\n            } // Normalize byteOffset: negative offsets start from the end of the buffer\n\n\n            if (byteOffset < 0) byteOffset = buffer.length + byteOffset;\n\n            if (byteOffset >= buffer.length) {\n              if (dir) return -1;else byteOffset = buffer.length - 1;\n            } else if (byteOffset < 0) {\n              if (dir) byteOffset = 0;else return -1;\n            } // Normalize val\n\n\n            if (typeof val === 'string') {\n              val = Buffer.from(val, encoding);\n            } // Finally, search either indexOf (if dir is true) or lastIndexOf\n\n\n            if (Buffer.isBuffer(val)) {\n              // Special case: looking for empty string/buffer always fails\n              if (val.length === 0) {\n                return -1;\n              }\n\n              return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n            } else if (typeof val === 'number') {\n              val = val & 0xFF; // Search for a byte value [0-255]\n\n              if (typeof Uint8Array.prototype.indexOf === 'function') {\n                if (dir) {\n                  return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n                } else {\n                  return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n                }\n              }\n\n              return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n            }\n\n            throw new TypeError('val must be string, number or Buffer');\n          }\n\n          function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n            var indexSize = 1;\n            var arrLength = arr.length;\n            var valLength = val.length;\n\n            if (encoding !== undefined) {\n              encoding = String(encoding).toLowerCase();\n\n              if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {\n                if (arr.length < 2 || val.length < 2) {\n                  return -1;\n                }\n\n                indexSize = 2;\n                arrLength /= 2;\n                valLength /= 2;\n                byteOffset /= 2;\n              }\n            }\n\n            function read(buf, i) {\n              if (indexSize === 1) {\n                return buf[i];\n              } else {\n                return buf.readUInt16BE(i * indexSize);\n              }\n            }\n\n            var i;\n\n            if (dir) {\n              var foundIndex = -1;\n\n              for (i = byteOffset; i < arrLength; i++) {\n                if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n                  if (foundIndex === -1) foundIndex = i;\n                  if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;\n                } else {\n                  if (foundIndex !== -1) i -= i - foundIndex;\n                  foundIndex = -1;\n                }\n              }\n            } else {\n              if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;\n\n              for (i = byteOffset; i >= 0; i--) {\n                var found = true;\n\n                for (var j = 0; j < valLength; j++) {\n                  if (read(arr, i + j) !== read(val, j)) {\n                    found = false;\n                    break;\n                  }\n                }\n\n                if (found) return i;\n              }\n            }\n\n            return -1;\n          }\n\n          Buffer.prototype.includes = function includes(val, byteOffset, encoding) {\n            return this.indexOf(val, byteOffset, encoding) !== -1;\n          };\n\n          Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n          };\n\n          Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n            return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n          };\n\n          function hexWrite(buf, string, offset, length) {\n            offset = Number(offset) || 0;\n            var remaining = buf.length - offset;\n\n            if (!length) {\n              length = remaining;\n            } else {\n              length = Number(length);\n\n              if (length > remaining) {\n                length = remaining;\n              }\n            }\n\n            var strLen = string.length;\n\n            if (length > strLen / 2) {\n              length = strLen / 2;\n            }\n\n            for (var i = 0; i < length; ++i) {\n              var parsed = parseInt(string.substr(i * 2, 2), 16);\n              if (numberIsNaN(parsed)) return i;\n              buf[offset + i] = parsed;\n            }\n\n            return i;\n          }\n\n          function utf8Write(buf, string, offset, length) {\n            return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          function asciiWrite(buf, string, offset, length) {\n            return blitBuffer(asciiToBytes(string), buf, offset, length);\n          }\n\n          function base64Write(buf, string, offset, length) {\n            return blitBuffer(base64ToBytes(string), buf, offset, length);\n          }\n\n          function ucs2Write(buf, string, offset, length) {\n            return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);\n          }\n\n          Buffer.prototype.write = function write(string, offset, length, encoding) {\n            // Buffer#write(string)\n            if (offset === undefined) {\n              encoding = 'utf8';\n              length = this.length;\n              offset = 0; // Buffer#write(string, encoding)\n            } else if (length === undefined && typeof offset === 'string') {\n              encoding = offset;\n              length = this.length;\n              offset = 0; // Buffer#write(string, offset[, length][, encoding])\n            } else if (isFinite(offset)) {\n              offset = offset >>> 0;\n\n              if (isFinite(length)) {\n                length = length >>> 0;\n                if (encoding === undefined) encoding = 'utf8';\n              } else {\n                encoding = length;\n                length = undefined;\n              }\n            } else {\n              throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');\n            }\n\n            var remaining = this.length - offset;\n            if (length === undefined || length > remaining) length = remaining;\n\n            if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {\n              throw new RangeError('Attempt to write outside buffer bounds');\n            }\n\n            if (!encoding) encoding = 'utf8';\n            var loweredCase = false;\n\n            for (;;) {\n              switch (encoding) {\n                case 'hex':\n                  return hexWrite(this, string, offset, length);\n\n                case 'utf8':\n                case 'utf-8':\n                  return utf8Write(this, string, offset, length);\n\n                case 'ascii':\n                case 'latin1':\n                case 'binary':\n                  return asciiWrite(this, string, offset, length);\n\n                case 'base64':\n                  // Warning: maxLength not taken into account in base64Write\n                  return base64Write(this, string, offset, length);\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return ucs2Write(this, string, offset, length);\n\n                default:\n                  if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);\n                  encoding = ('' + encoding).toLowerCase();\n                  loweredCase = true;\n              }\n            }\n          };\n\n          Buffer.prototype.toJSON = function toJSON() {\n            return {\n              type: 'Buffer',\n              data: Array.prototype.slice.call(this._arr || this, 0)\n            };\n          };\n\n          function base64Slice(buf, start, end) {\n            if (start === 0 && end === buf.length) {\n              return base64.fromByteArray(buf);\n            } else {\n              return base64.fromByteArray(buf.slice(start, end));\n            }\n          }\n\n          function utf8Slice(buf, start, end) {\n            end = Math.min(buf.length, end);\n            var res = [];\n            var i = start;\n\n            while (i < end) {\n              var firstByte = buf[i];\n              var codePoint = null;\n              var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;\n\n              if (i + bytesPerSequence <= end) {\n                var secondByte, thirdByte, fourthByte, tempCodePoint;\n\n                switch (bytesPerSequence) {\n                  case 1:\n                    if (firstByte < 0x80) {\n                      codePoint = firstByte;\n                    }\n\n                    break;\n\n                  case 2:\n                    secondByte = buf[i + 1];\n\n                    if ((secondByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;\n\n                      if (tempCodePoint > 0x7F) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 3:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;\n\n                      if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                    break;\n\n                  case 4:\n                    secondByte = buf[i + 1];\n                    thirdByte = buf[i + 2];\n                    fourthByte = buf[i + 3];\n\n                    if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n                      tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;\n\n                      if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n                        codePoint = tempCodePoint;\n                      }\n                    }\n\n                }\n              }\n\n              if (codePoint === null) {\n                // we did not generate a valid codePoint so insert a\n                // replacement char (U+FFFD) and advance only 1 byte\n                codePoint = 0xFFFD;\n                bytesPerSequence = 1;\n              } else if (codePoint > 0xFFFF) {\n                // encode to utf16 (surrogate pair dance)\n                codePoint -= 0x10000;\n                res.push(codePoint >>> 10 & 0x3FF | 0xD800);\n                codePoint = 0xDC00 | codePoint & 0x3FF;\n              }\n\n              res.push(codePoint);\n              i += bytesPerSequence;\n            }\n\n            return decodeCodePointsArray(res);\n          } // Based on http://stackoverflow.com/a/22747272/680742, the browser with\n          // the lowest limit is Chrome, with 0x10000 args.\n          // We go 1 magnitude less, for safety\n\n\n          var MAX_ARGUMENTS_LENGTH = 0x1000;\n\n          function decodeCodePointsArray(codePoints) {\n            var len = codePoints.length;\n\n            if (len <= MAX_ARGUMENTS_LENGTH) {\n              return String.fromCharCode.apply(String, codePoints); // avoid extra slice()\n            } // Decode in chunks to avoid \"call stack size exceeded\".\n\n\n            var res = '';\n            var i = 0;\n\n            while (i < len) {\n              res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n            }\n\n            return res;\n          }\n\n          function asciiSlice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i] & 0x7F);\n            }\n\n            return ret;\n          }\n\n          function latin1Slice(buf, start, end) {\n            var ret = '';\n            end = Math.min(buf.length, end);\n\n            for (var i = start; i < end; ++i) {\n              ret += String.fromCharCode(buf[i]);\n            }\n\n            return ret;\n          }\n\n          function hexSlice(buf, start, end) {\n            var len = buf.length;\n            if (!start || start < 0) start = 0;\n            if (!end || end < 0 || end > len) end = len;\n            var out = '';\n\n            for (var i = start; i < end; ++i) {\n              out += hexSliceLookupTable[buf[i]];\n            }\n\n            return out;\n          }\n\n          function utf16leSlice(buf, start, end) {\n            var bytes = buf.slice(start, end);\n            var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n\n            for (var i = 0; i < bytes.length - 1; i += 2) {\n              res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n            }\n\n            return res;\n          }\n\n          Buffer.prototype.slice = function slice(start, end) {\n            var len = this.length;\n            start = ~~start;\n            end = end === undefined ? len : ~~end;\n\n            if (start < 0) {\n              start += len;\n              if (start < 0) start = 0;\n            } else if (start > len) {\n              start = len;\n            }\n\n            if (end < 0) {\n              end += len;\n              if (end < 0) end = 0;\n            } else if (end > len) {\n              end = len;\n            }\n\n            if (end < start) end = start;\n            var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance\n\n            Object.setPrototypeOf(newBuf, Buffer.prototype);\n            return newBuf;\n          };\n          /*\n           * Need to make sure that buffer isn't trying to write out of bounds.\n           */\n\n\n          function checkOffset(offset, ext, length) {\n            if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');\n            if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');\n          }\n\n          Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              checkOffset(offset, byteLength, this.length);\n            }\n\n            var val = this[offset + --byteLength];\n            var mul = 1;\n\n            while (byteLength > 0 && (mul *= 0x100)) {\n              val += this[offset + --byteLength] * mul;\n            }\n\n            return val;\n          };\n\n          Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            return this[offset];\n          };\n\n          Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] | this[offset + 1] << 8;\n          };\n\n          Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            return this[offset] << 8 | this[offset + 1];\n          };\n\n          Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;\n          };\n\n          Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);\n          };\n\n          Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var val = this[offset];\n            var mul = 1;\n            var i = 0;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              val += this[offset + i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n            if (!noAssert) checkOffset(offset, byteLength, this.length);\n            var i = byteLength;\n            var mul = 1;\n            var val = this[offset + --i];\n\n            while (i > 0 && (mul *= 0x100)) {\n              val += this[offset + --i] * mul;\n            }\n\n            mul *= 0x80;\n            if (val >= mul) val -= Math.pow(2, 8 * byteLength);\n            return val;\n          };\n\n          Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 1, this.length);\n            if (!(this[offset] & 0x80)) return this[offset];\n            return (0xff - this[offset] + 1) * -1;\n          };\n\n          Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset] | this[offset + 1] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 2, this.length);\n            var val = this[offset + 1] | this[offset] << 8;\n            return val & 0x8000 ? val | 0xFFFF0000 : val;\n          };\n\n          Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;\n          };\n\n          Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];\n          };\n\n          Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, true, 23, 4);\n          };\n\n          Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 4, this.length);\n            return ieee754.read(this, offset, false, 23, 4);\n          };\n\n          Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, true, 52, 8);\n          };\n\n          Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {\n            offset = offset >>> 0;\n            if (!noAssert) checkOffset(offset, 8, this.length);\n            return ieee754.read(this, offset, false, 52, 8);\n          };\n\n          function checkInt(buf, value, offset, ext, max, min) {\n            if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance');\n            if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds');\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n          }\n\n          Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var mul = 1;\n            var i = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            byteLength = byteLength >>> 0;\n\n            if (!noAssert) {\n              var maxBytes = Math.pow(2, 8 * byteLength) - 1;\n              checkInt(this, value, offset, byteLength, maxBytes, 0);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              this[offset + i] = value / mul & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset + 3] = value >>> 24;\n            this[offset + 2] = value >>> 16;\n            this[offset + 1] = value >>> 8;\n            this[offset] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = 0;\n            var mul = 1;\n            var sub = 0;\n            this[offset] = value & 0xFF;\n\n            while (++i < byteLength && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              var limit = Math.pow(2, 8 * byteLength - 1);\n              checkInt(this, value, offset, byteLength, limit - 1, -limit);\n            }\n\n            var i = byteLength - 1;\n            var mul = 1;\n            var sub = 0;\n            this[offset + i] = value & 0xFF;\n\n            while (--i >= 0 && (mul *= 0x100)) {\n              if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n                sub = 1;\n              }\n\n              this[offset + i] = (value / mul >> 0) - sub & 0xFF;\n            }\n\n            return offset + byteLength;\n          };\n\n          Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);\n            if (value < 0) value = 0xff + value + 1;\n            this[offset] = value & 0xff;\n            return offset + 1;\n          };\n\n          Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);\n            this[offset] = value >>> 8;\n            this[offset + 1] = value & 0xff;\n            return offset + 2;\n          };\n\n          Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            this[offset] = value & 0xff;\n            this[offset + 1] = value >>> 8;\n            this[offset + 2] = value >>> 16;\n            this[offset + 3] = value >>> 24;\n            return offset + 4;\n          };\n\n          Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n            if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);\n            if (value < 0) value = 0xffffffff + value + 1;\n            this[offset] = value >>> 24;\n            this[offset + 1] = value >>> 16;\n            this[offset + 2] = value >>> 8;\n            this[offset + 3] = value & 0xff;\n            return offset + 4;\n          };\n\n          function checkIEEE754(buf, value, offset, ext, max, min) {\n            if (offset + ext > buf.length) throw new RangeError('Index out of range');\n            if (offset < 0) throw new RangeError('Index out of range');\n          }\n\n          function writeFloat(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 23, 4);\n            return offset + 4;\n          }\n\n          Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {\n            return writeFloat(this, value, offset, false, noAssert);\n          };\n\n          function writeDouble(buf, value, offset, littleEndian, noAssert) {\n            value = +value;\n            offset = offset >>> 0;\n\n            if (!noAssert) {\n              checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);\n            }\n\n            ieee754.write(buf, value, offset, littleEndian, 52, 8);\n            return offset + 8;\n          }\n\n          Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, true, noAssert);\n          };\n\n          Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {\n            return writeDouble(this, value, offset, false, noAssert);\n          }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\n\n\n          Buffer.prototype.copy = function copy(target, targetStart, start, end) {\n            if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');\n            if (!start) start = 0;\n            if (!end && end !== 0) end = this.length;\n            if (targetStart >= target.length) targetStart = target.length;\n            if (!targetStart) targetStart = 0;\n            if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done\n\n            if (end === start) return 0;\n            if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions\n\n            if (targetStart < 0) {\n              throw new RangeError('targetStart out of bounds');\n            }\n\n            if (start < 0 || start >= this.length) throw new RangeError('Index out of range');\n            if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?\n\n            if (end > this.length) end = this.length;\n\n            if (target.length - targetStart < end - start) {\n              end = target.length - targetStart + start;\n            }\n\n            var len = end - start;\n\n            if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n              // Use built-in when available, missing from IE11\n              this.copyWithin(targetStart, start, end);\n            } else {\n              Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n            }\n\n            return len;\n          }; // Usage:\n          //    buffer.fill(number[, offset[, end]])\n          //    buffer.fill(buffer[, offset[, end]])\n          //    buffer.fill(string[, offset[, end]][, encoding])\n\n\n          Buffer.prototype.fill = function fill(val, start, end, encoding) {\n            // Handle string cases:\n            if (typeof val === 'string') {\n              if (typeof start === 'string') {\n                encoding = start;\n                start = 0;\n                end = this.length;\n              } else if (typeof end === 'string') {\n                encoding = end;\n                end = this.length;\n              }\n\n              if (encoding !== undefined && typeof encoding !== 'string') {\n                throw new TypeError('encoding must be a string');\n              }\n\n              if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n                throw new TypeError('Unknown encoding: ' + encoding);\n              }\n\n              if (val.length === 1) {\n                var code = val.charCodeAt(0);\n\n                if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {\n                  // Fast path: If `val` fits into a single byte, use that numeric value.\n                  val = code;\n                }\n              }\n            } else if (typeof val === 'number') {\n              val = val & 255;\n            } else if (typeof val === 'boolean') {\n              val = Number(val);\n            } // Invalid ranges are not set to a default, so can range check early.\n\n\n            if (start < 0 || this.length < start || this.length < end) {\n              throw new RangeError('Out of range index');\n            }\n\n            if (end <= start) {\n              return this;\n            }\n\n            start = start >>> 0;\n            end = end === undefined ? this.length : end >>> 0;\n            if (!val) val = 0;\n            var i;\n\n            if (typeof val === 'number') {\n              for (i = start; i < end; ++i) {\n                this[i] = val;\n              }\n            } else {\n              var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);\n              var len = bytes.length;\n\n              if (len === 0) {\n                throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n              }\n\n              for (i = 0; i < end - start; ++i) {\n                this[i + start] = bytes[i % len];\n              }\n            }\n\n            return this;\n          }; // HELPER FUNCTIONS\n          // ================\n\n\n          var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n\n          function base64clean(str) {\n            // Node takes equal signs as end of the Base64 encoding\n            str = str.split('=')[0]; // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n\n            str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''\n\n            if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n\n            while (str.length % 4 !== 0) {\n              str = str + '=';\n            }\n\n            return str;\n          }\n\n          function utf8ToBytes(string, units) {\n            units = units || Infinity;\n            var codePoint;\n            var length = string.length;\n            var leadSurrogate = null;\n            var bytes = [];\n\n            for (var i = 0; i < length; ++i) {\n              codePoint = string.charCodeAt(i); // is surrogate component\n\n              if (codePoint > 0xD7FF && codePoint < 0xE000) {\n                // last char was a lead\n                if (!leadSurrogate) {\n                  // no lead yet\n                  if (codePoint > 0xDBFF) {\n                    // unexpected trail\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } else if (i + 1 === length) {\n                    // unpaired lead\n                    if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                    continue;\n                  } // valid lead\n\n\n                  leadSurrogate = codePoint;\n                  continue;\n                } // 2 leads in a row\n\n\n                if (codePoint < 0xDC00) {\n                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n                  leadSurrogate = codePoint;\n                  continue;\n                } // valid surrogate pair\n\n\n                codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;\n              } else if (leadSurrogate) {\n                // valid bmp char, but last char was a lead\n                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);\n              }\n\n              leadSurrogate = null; // encode utf8\n\n              if (codePoint < 0x80) {\n                if ((units -= 1) < 0) break;\n                bytes.push(codePoint);\n              } else if (codePoint < 0x800) {\n                if ((units -= 2) < 0) break;\n                bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x10000) {\n                if ((units -= 3) < 0) break;\n                bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else if (codePoint < 0x110000) {\n                if ((units -= 4) < 0) break;\n                bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);\n              } else {\n                throw new Error('Invalid code point');\n              }\n            }\n\n            return bytes;\n          }\n\n          function asciiToBytes(str) {\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              // Node's code seems to be doing this and not & 0x7F..\n              byteArray.push(str.charCodeAt(i) & 0xFF);\n            }\n\n            return byteArray;\n          }\n\n          function utf16leToBytes(str, units) {\n            var c, hi, lo;\n            var byteArray = [];\n\n            for (var i = 0; i < str.length; ++i) {\n              if ((units -= 2) < 0) break;\n              c = str.charCodeAt(i);\n              hi = c >> 8;\n              lo = c % 256;\n              byteArray.push(lo);\n              byteArray.push(hi);\n            }\n\n            return byteArray;\n          }\n\n          function base64ToBytes(str) {\n            return base64.toByteArray(base64clean(str));\n          }\n\n          function blitBuffer(src, dst, offset, length) {\n            for (var i = 0; i < length; ++i) {\n              if (i + offset >= dst.length || i >= src.length) break;\n              dst[i + offset] = src[i];\n            }\n\n            return i;\n          } // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n          // the `instanceof` check but they should be treated as of that type.\n          // See: https://github.com/feross/buffer/issues/166\n\n\n          function isInstance(obj, type) {\n            return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;\n          }\n\n          function numberIsNaN(obj) {\n            // For IE11 support\n            return obj !== obj; // eslint-disable-line no-self-compare\n          } // Create lookup table for `toString('hex')`\n          // See: https://github.com/feross/buffer/issues/219\n\n\n          var hexSliceLookupTable = function () {\n            var alphabet = '0123456789abcdef';\n            var table = new Array(256);\n\n            for (var i = 0; i < 16; ++i) {\n              var i16 = i * 16;\n\n              for (var j = 0; j < 16; ++j) {\n                table[i16 + j] = alphabet[i] + alphabet[j];\n              }\n            }\n\n            return table;\n          }();\n          /***/\n\n        },\n\n        /***/\n        584:\n        /***/\n        module => {\n          module.exports = {\n            \"100\": \"Continue\",\n            \"101\": \"Switching Protocols\",\n            \"102\": \"Processing\",\n            \"200\": \"OK\",\n            \"201\": \"Created\",\n            \"202\": \"Accepted\",\n            \"203\": \"Non-Authoritative Information\",\n            \"204\": \"No Content\",\n            \"205\": \"Reset Content\",\n            \"206\": \"Partial Content\",\n            \"207\": \"Multi-Status\",\n            \"208\": \"Already Reported\",\n            \"226\": \"IM Used\",\n            \"300\": \"Multiple Choices\",\n            \"301\": \"Moved Permanently\",\n            \"302\": \"Found\",\n            \"303\": \"See Other\",\n            \"304\": \"Not Modified\",\n            \"305\": \"Use Proxy\",\n            \"307\": \"Temporary Redirect\",\n            \"308\": \"Permanent Redirect\",\n            \"400\": \"Bad Request\",\n            \"401\": \"Unauthorized\",\n            \"402\": \"Payment Required\",\n            \"403\": \"Forbidden\",\n            \"404\": \"Not Found\",\n            \"405\": \"Method Not Allowed\",\n            \"406\": \"Not Acceptable\",\n            \"407\": \"Proxy Authentication Required\",\n            \"408\": \"Request Timeout\",\n            \"409\": \"Conflict\",\n            \"410\": \"Gone\",\n            \"411\": \"Length Required\",\n            \"412\": \"Precondition Failed\",\n            \"413\": \"Payload Too Large\",\n            \"414\": \"URI Too Long\",\n            \"415\": \"Unsupported Media Type\",\n            \"416\": \"Range Not Satisfiable\",\n            \"417\": \"Expectation Failed\",\n            \"418\": \"I'm a teapot\",\n            \"421\": \"Misdirected Request\",\n            \"422\": \"Unprocessable Entity\",\n            \"423\": \"Locked\",\n            \"424\": \"Failed Dependency\",\n            \"425\": \"Unordered Collection\",\n            \"426\": \"Upgrade Required\",\n            \"428\": \"Precondition Required\",\n            \"429\": \"Too Many Requests\",\n            \"431\": \"Request Header Fields Too Large\",\n            \"451\": \"Unavailable For Legal Reasons\",\n            \"500\": \"Internal Server Error\",\n            \"501\": \"Not Implemented\",\n            \"502\": \"Bad Gateway\",\n            \"503\": \"Service Unavailable\",\n            \"504\": \"Gateway Timeout\",\n            \"505\": \"HTTP Version Not Supported\",\n            \"506\": \"Variant Also Negotiates\",\n            \"507\": \"Insufficient Storage\",\n            \"508\": \"Loop Detected\",\n            \"509\": \"Bandwidth Limit Exceeded\",\n            \"510\": \"Not Extended\",\n            \"511\": \"Network Authentication Required\"\n          };\n          /***/\n        },\n\n        /***/\n        187:\n        /***/\n        module => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n          var R = typeof Reflect === 'object' ? Reflect : null;\n          var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {\n            return Function.prototype.apply.call(target, receiver, args);\n          };\n          var ReflectOwnKeys;\n\n          if (R && typeof R.ownKeys === 'function') {\n            ReflectOwnKeys = R.ownKeys;\n          } else if (Object.getOwnPropertySymbols) {\n            ReflectOwnKeys = function ReflectOwnKeys(target) {\n              return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n            };\n          } else {\n            ReflectOwnKeys = function ReflectOwnKeys(target) {\n              return Object.getOwnPropertyNames(target);\n            };\n          }\n\n          function ProcessEmitWarning(warning) {\n            if (console && console.warn) console.warn(warning);\n          }\n\n          var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n            return value !== value;\n          };\n\n          function EventEmitter() {\n            EventEmitter.init.call(this);\n          }\n\n          module.exports = EventEmitter;\n          module.exports.once = once; // Backwards-compat with node 0.10.x\n\n          EventEmitter.EventEmitter = EventEmitter;\n          EventEmitter.prototype._events = undefined;\n          EventEmitter.prototype._eventsCount = 0;\n          EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are\n          // added to it. This is a useful default which helps finding memory leaks.\n\n          var defaultMaxListeners = 10;\n\n          function checkListener(listener) {\n            if (typeof listener !== 'function') {\n              throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n            }\n          }\n\n          Object.defineProperty(EventEmitter, 'defaultMaxListeners', {\n            enumerable: true,\n            get: function () {\n              return defaultMaxListeners;\n            },\n            set: function (arg) {\n              if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n                throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n              }\n\n              defaultMaxListeners = arg;\n            }\n          });\n\n          EventEmitter.init = function () {\n            if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n              this._events = Object.create(null);\n              this._eventsCount = 0;\n            }\n\n            this._maxListeners = this._maxListeners || undefined;\n          }; // Obviously not all Emitters should be limited to 10. This function allows\n          // that to be increased. Set to zero for unlimited.\n\n\n          EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n            if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n              throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n            }\n\n            this._maxListeners = n;\n            return this;\n          };\n\n          function _getMaxListeners(that) {\n            if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n            return that._maxListeners;\n          }\n\n          EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n            return _getMaxListeners(this);\n          };\n\n          EventEmitter.prototype.emit = function emit(type) {\n            var args = [];\n\n            for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n\n            var doError = type === 'error';\n            var events = this._events;\n            if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.\n\n            if (doError) {\n              var er;\n              if (args.length > 0) er = args[0];\n\n              if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n              } // At least give some kind of context to the user\n\n\n              var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n              err.context = er;\n              throw err; // Unhandled 'error' event\n            }\n\n            var handler = events[type];\n            if (handler === undefined) return false;\n\n            if (typeof handler === 'function') {\n              ReflectApply(handler, this, args);\n            } else {\n              var len = handler.length;\n              var listeners = arrayClone(handler, len);\n\n              for (var i = 0; i < len; ++i) ReflectApply(listeners[i], this, args);\n            }\n\n            return true;\n          };\n\n          function _addListener(target, type, listener, prepend) {\n            var m;\n            var events;\n            var existing;\n            checkListener(listener);\n            events = target._events;\n\n            if (events === undefined) {\n              events = target._events = Object.create(null);\n              target._eventsCount = 0;\n            } else {\n              // To avoid recursion in the case that type === \"newListener\"! Before\n              // adding it to the listeners, first emit \"newListener\".\n              if (events.newListener !== undefined) {\n                target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the\n                // this._events to be assigned to a new object\n\n                events = target._events;\n              }\n\n              existing = events[type];\n            }\n\n            if (existing === undefined) {\n              // Optimize the case of one listener. Don't need the extra array object.\n              existing = events[type] = listener;\n              ++target._eventsCount;\n            } else {\n              if (typeof existing === 'function') {\n                // Adding the second element, need to change to array.\n                existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.\n              } else if (prepend) {\n                existing.unshift(listener);\n              } else {\n                existing.push(listener);\n              } // Check for listener leak\n\n\n              m = _getMaxListeners(target);\n\n              if (m > 0 && existing.length > m && !existing.warned) {\n                existing.warned = true; // No error code for this since it is a Warning\n                // eslint-disable-next-line no-restricted-syntax\n\n                var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');\n                w.name = 'MaxListenersExceededWarning';\n                w.emitter = target;\n                w.type = type;\n                w.count = existing.length;\n                ProcessEmitWarning(w);\n              }\n            }\n\n            return target;\n          }\n\n          EventEmitter.prototype.addListener = function addListener(type, listener) {\n            return _addListener(this, type, listener, false);\n          };\n\n          EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n          EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n            return _addListener(this, type, listener, true);\n          };\n\n          function onceWrapper() {\n            if (!this.fired) {\n              this.target.removeListener(this.type, this.wrapFn);\n              this.fired = true;\n              if (arguments.length === 0) return this.listener.call(this.target);\n              return this.listener.apply(this.target, arguments);\n            }\n          }\n\n          function _onceWrap(target, type, listener) {\n            var state = {\n              fired: false,\n              wrapFn: undefined,\n              target: target,\n              type: type,\n              listener: listener\n            };\n            var wrapped = onceWrapper.bind(state);\n            wrapped.listener = listener;\n            state.wrapFn = wrapped;\n            return wrapped;\n          }\n\n          EventEmitter.prototype.once = function once(type, listener) {\n            checkListener(listener);\n            this.on(type, _onceWrap(this, type, listener));\n            return this;\n          };\n\n          EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n            checkListener(listener);\n            this.prependListener(type, _onceWrap(this, type, listener));\n            return this;\n          }; // Emits a 'removeListener' event if and only if the listener was removed.\n\n\n          EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n            var list, events, position, i, originalListener;\n            checkListener(listener);\n            events = this._events;\n            if (events === undefined) return this;\n            list = events[type];\n            if (list === undefined) return this;\n\n            if (list === listener || list.listener === listener) {\n              if (--this._eventsCount === 0) this._events = Object.create(null);else {\n                delete events[type];\n                if (events.removeListener) this.emit('removeListener', type, list.listener || listener);\n              }\n            } else if (typeof list !== 'function') {\n              position = -1;\n\n              for (i = list.length - 1; i >= 0; i--) {\n                if (list[i] === listener || list[i].listener === listener) {\n                  originalListener = list[i].listener;\n                  position = i;\n                  break;\n                }\n              }\n\n              if (position < 0) return this;\n              if (position === 0) list.shift();else {\n                spliceOne(list, position);\n              }\n              if (list.length === 1) events[type] = list[0];\n              if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);\n            }\n\n            return this;\n          };\n\n          EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n          EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n            var listeners, events, i;\n            events = this._events;\n            if (events === undefined) return this; // not listening for removeListener, no need to emit\n\n            if (events.removeListener === undefined) {\n              if (arguments.length === 0) {\n                this._events = Object.create(null);\n                this._eventsCount = 0;\n              } else if (events[type] !== undefined) {\n                if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];\n              }\n\n              return this;\n            } // emit removeListener for all listeners on all events\n\n\n            if (arguments.length === 0) {\n              var keys = Object.keys(events);\n              var key;\n\n              for (i = 0; i < keys.length; ++i) {\n                key = keys[i];\n                if (key === 'removeListener') continue;\n                this.removeAllListeners(key);\n              }\n\n              this.removeAllListeners('removeListener');\n              this._events = Object.create(null);\n              this._eventsCount = 0;\n              return this;\n            }\n\n            listeners = events[type];\n\n            if (typeof listeners === 'function') {\n              this.removeListener(type, listeners);\n            } else if (listeners !== undefined) {\n              // LIFO order\n              for (i = listeners.length - 1; i >= 0; i--) {\n                this.removeListener(type, listeners[i]);\n              }\n            }\n\n            return this;\n          };\n\n          function _listeners(target, type, unwrap) {\n            var events = target._events;\n            if (events === undefined) return [];\n            var evlistener = events[type];\n            if (evlistener === undefined) return [];\n            if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n            return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n          }\n\n          EventEmitter.prototype.listeners = function listeners(type) {\n            return _listeners(this, type, true);\n          };\n\n          EventEmitter.prototype.rawListeners = function rawListeners(type) {\n            return _listeners(this, type, false);\n          };\n\n          EventEmitter.listenerCount = function (emitter, type) {\n            if (typeof emitter.listenerCount === 'function') {\n              return emitter.listenerCount(type);\n            } else {\n              return listenerCount.call(emitter, type);\n            }\n          };\n\n          EventEmitter.prototype.listenerCount = listenerCount;\n\n          function listenerCount(type) {\n            var events = this._events;\n\n            if (events !== undefined) {\n              var evlistener = events[type];\n\n              if (typeof evlistener === 'function') {\n                return 1;\n              } else if (evlistener !== undefined) {\n                return evlistener.length;\n              }\n            }\n\n            return 0;\n          }\n\n          EventEmitter.prototype.eventNames = function eventNames() {\n            return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n          };\n\n          function arrayClone(arr, n) {\n            var copy = new Array(n);\n\n            for (var i = 0; i < n; ++i) copy[i] = arr[i];\n\n            return copy;\n          }\n\n          function spliceOne(list, index) {\n            for (; index + 1 < list.length; index++) list[index] = list[index + 1];\n\n            list.pop();\n          }\n\n          function unwrapListeners(arr) {\n            var ret = new Array(arr.length);\n\n            for (var i = 0; i < ret.length; ++i) {\n              ret[i] = arr[i].listener || arr[i];\n            }\n\n            return ret;\n          }\n\n          function once(emitter, name) {\n            return new Promise(function (resolve, reject) {\n              function eventListener() {\n                if (errorListener !== undefined) {\n                  emitter.removeListener('error', errorListener);\n                }\n\n                resolve([].slice.call(arguments));\n              }\n\n              ;\n              var errorListener; // Adding an error listener is not optional because\n              // if an error is thrown on an event emitter we cannot\n              // guarantee that the actual event we are waiting will\n              // be fired. The result could be a silent way to create\n              // memory or file descriptor leaks, which is something\n              // we should avoid.\n\n              if (name !== 'error') {\n                errorListener = function errorListener(err) {\n                  emitter.removeListener(name, eventListener);\n                  reject(err);\n                };\n\n                emitter.once('error', errorListener);\n              }\n\n              emitter.once(name, eventListener);\n            });\n          }\n          /***/\n\n        },\n\n        /***/\n        645:\n        /***/\n        (__unused_webpack_module, exports) => {\n          /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\n          exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n            var e, m;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var nBits = -7;\n            var i = isLE ? nBytes - 1 : 0;\n            var d = isLE ? -1 : 1;\n            var s = buffer[offset + i];\n            i += d;\n            e = s & (1 << -nBits) - 1;\n            s >>= -nBits;\n            nBits += eLen;\n\n            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n            m = e & (1 << -nBits) - 1;\n            e >>= -nBits;\n            nBits += mLen;\n\n            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n            if (e === 0) {\n              e = 1 - eBias;\n            } else if (e === eMax) {\n              return m ? NaN : (s ? -1 : 1) * Infinity;\n            } else {\n              m = m + Math.pow(2, mLen);\n              e = e - eBias;\n            }\n\n            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n          };\n\n          exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n            var e, m, c;\n            var eLen = nBytes * 8 - mLen - 1;\n            var eMax = (1 << eLen) - 1;\n            var eBias = eMax >> 1;\n            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n            var i = isLE ? 0 : nBytes - 1;\n            var d = isLE ? 1 : -1;\n            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n            value = Math.abs(value);\n\n            if (isNaN(value) || value === Infinity) {\n              m = isNaN(value) ? 1 : 0;\n              e = eMax;\n            } else {\n              e = Math.floor(Math.log(value) / Math.LN2);\n\n              if (value * (c = Math.pow(2, -e)) < 1) {\n                e--;\n                c *= 2;\n              }\n\n              if (e + eBias >= 1) {\n                value += rt / c;\n              } else {\n                value += rt * Math.pow(2, 1 - eBias);\n              }\n\n              if (value * c >= 2) {\n                e++;\n                c /= 2;\n              }\n\n              if (e + eBias >= eMax) {\n                m = 0;\n                e = eMax;\n              } else if (e + eBias >= 1) {\n                m = (value * c - 1) * Math.pow(2, mLen);\n                e = e + eBias;\n              } else {\n                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n                e = 0;\n              }\n            }\n\n            for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n            e = e << mLen | m;\n            eLen += mLen;\n\n            for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n            buffer[offset + i - d] |= s * 128;\n          };\n          /***/\n\n        },\n\n        /***/\n        717:\n        /***/\n        module => {\n          if (typeof Object.create === 'function') {\n            // implementation from standard node.js 'util' module\n            module.exports = function inherits(ctor, superCtor) {\n              if (superCtor) {\n                ctor.super_ = superCtor;\n                ctor.prototype = Object.create(superCtor.prototype, {\n                  constructor: {\n                    value: ctor,\n                    enumerable: false,\n                    writable: true,\n                    configurable: true\n                  }\n                });\n              }\n            };\n          } else {\n            // old school shim for old browsers\n            module.exports = function inherits(ctor, superCtor) {\n              if (superCtor) {\n                ctor.super_ = superCtor;\n\n                var TempCtor = function () {};\n\n                TempCtor.prototype = superCtor.prototype;\n                ctor.prototype = new TempCtor();\n                ctor.prototype.constructor = ctor;\n              }\n            };\n          }\n          /***/\n\n        },\n\n        /***/\n        587:\n        /***/\n        module => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // If obj.hasOwnProperty has been overridden, then calling\n          // obj.hasOwnProperty(prop) will break.\n          // See: https://github.com/joyent/node/issues/1707\n\n          function hasOwnProperty(obj, prop) {\n            return Object.prototype.hasOwnProperty.call(obj, prop);\n          }\n\n          module.exports = function (qs, sep, eq, options) {\n            sep = sep || '&';\n            eq = eq || '=';\n            var obj = {};\n\n            if (typeof qs !== 'string' || qs.length === 0) {\n              return obj;\n            }\n\n            var regexp = /\\+/g;\n            qs = qs.split(sep);\n            var maxKeys = 1000;\n\n            if (options && typeof options.maxKeys === 'number') {\n              maxKeys = options.maxKeys;\n            }\n\n            var len = qs.length; // maxKeys <= 0 means that we should not limit keys count\n\n            if (maxKeys > 0 && len > maxKeys) {\n              len = maxKeys;\n            }\n\n            for (var i = 0; i < len; ++i) {\n              var x = qs[i].replace(regexp, '%20'),\n                  idx = x.indexOf(eq),\n                  kstr,\n                  vstr,\n                  k,\n                  v;\n\n              if (idx >= 0) {\n                kstr = x.substr(0, idx);\n                vstr = x.substr(idx + 1);\n              } else {\n                kstr = x;\n                vstr = '';\n              }\n\n              k = decodeURIComponent(kstr);\n              v = decodeURIComponent(vstr);\n\n              if (!hasOwnProperty(obj, k)) {\n                obj[k] = v;\n              } else if (Array.isArray(obj[k])) {\n                obj[k].push(v);\n              } else {\n                obj[k] = [obj[k], v];\n              }\n            }\n\n            return obj;\n          };\n          /***/\n\n        },\n\n        /***/\n        361:\n        /***/\n        module => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n          var stringifyPrimitive = function (v) {\n            switch (typeof v) {\n              case 'string':\n                return v;\n\n              case 'boolean':\n                return v ? 'true' : 'false';\n\n              case 'number':\n                return isFinite(v) ? v : '';\n\n              default:\n                return '';\n            }\n          };\n\n          module.exports = function (obj, sep, eq, name) {\n            sep = sep || '&';\n            eq = eq || '=';\n\n            if (obj === null) {\n              obj = undefined;\n            }\n\n            if (typeof obj === 'object') {\n              return Object.keys(obj).map(function (k) {\n                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n\n                if (Array.isArray(obj[k])) {\n                  return obj[k].map(function (v) {\n                    return ks + encodeURIComponent(stringifyPrimitive(v));\n                  }).join(sep);\n                } else {\n                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n                }\n              }).join(sep);\n            }\n\n            if (!name) return '';\n            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));\n          };\n          /***/\n\n        },\n\n        /***/\n        673:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_125852__) => {\n          \"use strict\";\n\n          exports.decode = exports.parse = __nested_webpack_require_125852__(587);\n          exports.encode = exports.stringify = __nested_webpack_require_125852__(361);\n          /***/\n        },\n\n        /***/\n        509:\n        /***/\n        (module, exports, __nested_webpack_require_126140__) => {\n          /* eslint-disable node/no-deprecated-api */\n          var buffer = __nested_webpack_require_126140__(764);\n\n          var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers\n\n          function copyProps(src, dst) {\n            for (var key in src) {\n              dst[key] = src[key];\n            }\n          }\n\n          if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n            module.exports = buffer;\n          } else {\n            // Copy properties from require('buffer')\n            copyProps(buffer, exports);\n            exports.Buffer = SafeBuffer;\n          }\n\n          function SafeBuffer(arg, encodingOrOffset, length) {\n            return Buffer(arg, encodingOrOffset, length);\n          } // Copy static methods from Buffer\n\n\n          copyProps(Buffer, SafeBuffer);\n\n          SafeBuffer.from = function (arg, encodingOrOffset, length) {\n            if (typeof arg === 'number') {\n              throw new TypeError('Argument must not be a number');\n            }\n\n            return Buffer(arg, encodingOrOffset, length);\n          };\n\n          SafeBuffer.alloc = function (size, fill, encoding) {\n            if (typeof size !== 'number') {\n              throw new TypeError('Argument must be a number');\n            }\n\n            var buf = Buffer(size);\n\n            if (fill !== undefined) {\n              if (typeof encoding === 'string') {\n                buf.fill(fill, encoding);\n              } else {\n                buf.fill(fill);\n              }\n            } else {\n              buf.fill(0);\n            }\n\n            return buf;\n          };\n\n          SafeBuffer.allocUnsafe = function (size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('Argument must be a number');\n            }\n\n            return Buffer(size);\n          };\n\n          SafeBuffer.allocUnsafeSlow = function (size) {\n            if (typeof size !== 'number') {\n              throw new TypeError('Argument must be a number');\n            }\n\n            return buffer.SlowBuffer(size);\n          };\n          /***/\n\n        },\n\n        /***/\n        501:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_128376__) => {\n          var ClientRequest = __nested_webpack_require_128376__(989);\n\n          var response = __nested_webpack_require_128376__(676);\n\n          var extend = __nested_webpack_require_128376__(529);\n\n          var statusCodes = __nested_webpack_require_128376__(584);\n\n          var url = __nested_webpack_require_128376__(575);\n\n          var http = exports;\n\n          http.request = function (opts, cb) {\n            if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol\n            // will result in a (valid) protocol-relative url. However, this won't work if\n            // the protocol is something else, like 'file:'\n\n            var defaultProtocol = __nested_webpack_require_128376__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';\n            var protocol = opts.protocol || defaultProtocol;\n            var host = opts.hostname || opts.host;\n            var port = opts.port;\n            var path = opts.path || '/'; // Necessary for IPv6 addresses\n\n            if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.\n\n            opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;\n            opts.method = (opts.method || 'GET').toUpperCase();\n            opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode\n\n            var req = new ClientRequest(opts);\n            if (cb) req.on('response', cb);\n            return req;\n          };\n\n          http.get = function get(opts, cb) {\n            var req = http.request(opts, cb);\n            req.end();\n            return req;\n          };\n\n          http.ClientRequest = ClientRequest;\n          http.IncomingMessage = response.IncomingMessage;\n\n          http.Agent = function () {};\n\n          http.Agent.defaultMaxSockets = 4;\n          http.globalAgent = new http.Agent();\n          http.STATUS_CODES = statusCodes;\n          http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];\n          /***/\n        },\n\n        /***/\n        725:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_130775__) => {\n          exports.fetch = isFunction(__nested_webpack_require_130775__.g.fetch) && isFunction(__nested_webpack_require_130775__.g.ReadableStream);\n          exports.writableStream = isFunction(__nested_webpack_require_130775__.g.WritableStream);\n          exports.abortController = isFunction(__nested_webpack_require_130775__.g.AbortController); // The xhr request to example.com may violate some restrictive CSP configurations,\n          // so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n          // and assume support for certain features below.\n\n          var xhr;\n\n          function getXHR() {\n            // Cache the xhr value\n            if (xhr !== undefined) return xhr;\n\n            if (__nested_webpack_require_130775__.g.XMLHttpRequest) {\n              xhr = new __nested_webpack_require_130775__.g.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work\n              // cross domain), use the page location. Otherwise use example.com\n              // Note: this doesn't actually make an http request.\n\n              try {\n                xhr.open('GET', __nested_webpack_require_130775__.g.XDomainRequest ? '/' : 'https://example.com');\n              } catch (e) {\n                xhr = null;\n              }\n            } else {\n              // Service workers don't have XHR\n              xhr = null;\n            }\n\n            return xhr;\n          }\n\n          function checkTypeSupport(type) {\n            var xhr = getXHR();\n            if (!xhr) return false;\n\n            try {\n              xhr.responseType = type;\n              return xhr.responseType === type;\n            } catch (e) {}\n\n            return false;\n          } // If fetch is supported, then arraybuffer will be supported too. Skip calling\n          // checkTypeSupport(), since that calls getXHR().\n\n\n          exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer'); // These next two tests unavoidably show warnings in Chrome. Since fetch will always\n          // be used if it's available, just return false for these to avoid the warnings.\n\n          exports.msstream = !exports.fetch && checkTypeSupport('ms-stream');\n          exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer'); // If fetch is supported, then overrideMimeType will be supported too. Skip calling\n          // getXHR().\n\n          exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);\n\n          function isFunction(value) {\n            return typeof value === 'function';\n          }\n\n          xhr = null; // Help gc\n\n          /***/\n        },\n\n        /***/\n        989:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_133475__) => {\n          /* provided dependency */\n          var Buffer = __nested_webpack_require_133475__(764);\n\n          var capability = __nested_webpack_require_133475__(725);\n\n          var inherits = __nested_webpack_require_133475__(717);\n\n          var response = __nested_webpack_require_133475__(676);\n\n          var stream = __nested_webpack_require_133475__(925);\n\n          var IncomingMessage = response.IncomingMessage;\n          var rStates = response.readyStates;\n\n          function decideMode(preferBinary, useFetch) {\n            if (capability.fetch && useFetch) {\n              return 'fetch';\n            } else if (capability.mozchunkedarraybuffer) {\n              return 'moz-chunked-arraybuffer';\n            } else if (capability.msstream) {\n              return 'ms-stream';\n            } else if (capability.arraybuffer && preferBinary) {\n              return 'arraybuffer';\n            } else {\n              return 'text';\n            }\n          }\n\n          var ClientRequest = module.exports = function (opts) {\n            var self = this;\n            stream.Writable.call(self);\n            self._opts = opts;\n            self._body = [];\n            self._headers = {};\n            if (opts.auth) self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'));\n            Object.keys(opts.headers).forEach(function (name) {\n              self.setHeader(name, opts.headers[name]);\n            });\n            var preferBinary;\n            var useFetch = true;\n\n            if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {\n              // If the use of XHR should be preferred. Not typically needed.\n              useFetch = false;\n              preferBinary = true;\n            } else if (opts.mode === 'prefer-streaming') {\n              // If streaming is a high priority but binary compatibility and\n              // the accuracy of the 'content-type' header aren't\n              preferBinary = false;\n            } else if (opts.mode === 'allow-wrong-content-type') {\n              // If streaming is more important than preserving the 'content-type' header\n              preferBinary = !capability.overrideMimeType;\n            } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n              // Use binary if text streaming may corrupt data or the content-type header, or for speed\n              preferBinary = true;\n            } else {\n              throw new Error('Invalid value for opts.mode');\n            }\n\n            self._mode = decideMode(preferBinary, useFetch);\n            self._fetchTimer = null;\n            self.on('finish', function () {\n              self._onFinish();\n            });\n          };\n\n          inherits(ClientRequest, stream.Writable);\n\n          ClientRequest.prototype.setHeader = function (name, value) {\n            var self = this;\n            var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe\n            // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n            // http-browserify did it, so I will too.\n\n            if (unsafeHeaders.indexOf(lowerName) !== -1) return;\n            self._headers[lowerName] = {\n              name: name,\n              value: value\n            };\n          };\n\n          ClientRequest.prototype.getHeader = function (name) {\n            var header = this._headers[name.toLowerCase()];\n\n            if (header) return header.value;\n            return null;\n          };\n\n          ClientRequest.prototype.removeHeader = function (name) {\n            var self = this;\n            delete self._headers[name.toLowerCase()];\n          };\n\n          ClientRequest.prototype._onFinish = function () {\n            var self = this;\n            if (self._destroyed) return;\n            var opts = self._opts;\n            var headersObj = self._headers;\n            var body = null;\n\n            if (opts.method !== 'GET' && opts.method !== 'HEAD') {\n              body = new Blob(self._body, {\n                type: (headersObj['content-type'] || {}).value || ''\n              });\n            } // create flattened list of headers\n\n\n            var headersList = [];\n            Object.keys(headersObj).forEach(function (keyName) {\n              var name = headersObj[keyName].name;\n              var value = headersObj[keyName].value;\n\n              if (Array.isArray(value)) {\n                value.forEach(function (v) {\n                  headersList.push([name, v]);\n                });\n              } else {\n                headersList.push([name, value]);\n              }\n            });\n\n            if (self._mode === 'fetch') {\n              var signal = null;\n\n              if (capability.abortController) {\n                var controller = new AbortController();\n                signal = controller.signal;\n                self._fetchAbortController = controller;\n\n                if ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n                  self._fetchTimer = __nested_webpack_require_133475__.g.setTimeout(function () {\n                    self.emit('requestTimeout');\n                    if (self._fetchAbortController) self._fetchAbortController.abort();\n                  }, opts.requestTimeout);\n                }\n              }\n\n              __nested_webpack_require_133475__.g.fetch(self._opts.url, {\n                method: self._opts.method,\n                headers: headersList,\n                body: body || undefined,\n                mode: 'cors',\n                credentials: opts.withCredentials ? 'include' : 'same-origin',\n                signal: signal\n              }).then(function (response) {\n                self._fetchResponse = response;\n\n                self._connect();\n              }, function (reason) {\n                __nested_webpack_require_133475__.g.clearTimeout(self._fetchTimer);\n\n                if (!self._destroyed) self.emit('error', reason);\n              });\n            } else {\n              var xhr = self._xhr = new __nested_webpack_require_133475__.g.XMLHttpRequest();\n\n              try {\n                xhr.open(self._opts.method, self._opts.url, true);\n              } catch (err) {\n                process.nextTick(function () {\n                  self.emit('error', err);\n                });\n                return;\n              } // Can't set responseType on really old browsers\n\n\n              if ('responseType' in xhr) xhr.responseType = self._mode;\n              if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;\n              if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');\n\n              if ('requestTimeout' in opts) {\n                xhr.timeout = opts.requestTimeout;\n\n                xhr.ontimeout = function () {\n                  self.emit('requestTimeout');\n                };\n              }\n\n              headersList.forEach(function (header) {\n                xhr.setRequestHeader(header[0], header[1]);\n              });\n              self._response = null;\n\n              xhr.onreadystatechange = function () {\n                switch (xhr.readyState) {\n                  case rStates.LOADING:\n                  case rStates.DONE:\n                    self._onXHRProgress();\n\n                    break;\n                }\n              }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined\n              // in onprogress, not in onreadystatechange with xhr.readyState = 3\n\n\n              if (self._mode === 'moz-chunked-arraybuffer') {\n                xhr.onprogress = function () {\n                  self._onXHRProgress();\n                };\n              }\n\n              xhr.onerror = function () {\n                if (self._destroyed) return;\n                self.emit('error', new Error('XHR error'));\n              };\n\n              try {\n                xhr.send(body);\n              } catch (err) {\n                process.nextTick(function () {\n                  self.emit('error', err);\n                });\n                return;\n              }\n            }\n          };\n          /**\n           * Checks if xhr.status is readable and non-zero, indicating no error.\n           * Even though the spec says it should be available in readyState 3,\n           * accessing it throws an exception in IE8\n           */\n\n\n          function statusValid(xhr) {\n            try {\n              var status = xhr.status;\n              return status !== null && status !== 0;\n            } catch (e) {\n              return false;\n            }\n          }\n\n          ClientRequest.prototype._onXHRProgress = function () {\n            var self = this;\n            if (!statusValid(self._xhr) || self._destroyed) return;\n            if (!self._response) self._connect();\n\n            self._response._onXHRProgress();\n          };\n\n          ClientRequest.prototype._connect = function () {\n            var self = this;\n            if (self._destroyed) return;\n            self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer);\n\n            self._response.on('error', function (err) {\n              self.emit('error', err);\n            });\n\n            self.emit('response', self._response);\n          };\n\n          ClientRequest.prototype._write = function (chunk, encoding, cb) {\n            var self = this;\n\n            self._body.push(chunk);\n\n            cb();\n          };\n\n          ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n            var self = this;\n            self._destroyed = true;\n\n            __nested_webpack_require_133475__.g.clearTimeout(self._fetchTimer);\n\n            if (self._response) self._response._destroyed = true;\n            if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();\n          };\n\n          ClientRequest.prototype.end = function (data, encoding, cb) {\n            var self = this;\n\n            if (typeof data === 'function') {\n              cb = data;\n              data = undefined;\n            }\n\n            stream.Writable.prototype.end.call(self, data, encoding, cb);\n          };\n\n          ClientRequest.prototype.flushHeaders = function () {};\n\n          ClientRequest.prototype.setTimeout = function () {};\n\n          ClientRequest.prototype.setNoDelay = function () {};\n\n          ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\n\n\n          var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];\n          /***/\n        },\n\n        /***/\n        676:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_144445__) => {\n          /* provided dependency */\n          var Buffer = __nested_webpack_require_144445__(764);\n\n          var capability = __nested_webpack_require_144445__(725);\n\n          var inherits = __nested_webpack_require_144445__(717);\n\n          var stream = __nested_webpack_require_144445__(925);\n\n          var rStates = exports.readyStates = {\n            UNSENT: 0,\n            OPENED: 1,\n            HEADERS_RECEIVED: 2,\n            LOADING: 3,\n            DONE: 4\n          };\n\n          var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\n            var self = this;\n            stream.Readable.call(self);\n            self._mode = mode;\n            self.headers = {};\n            self.rawHeaders = [];\n            self.trailers = {};\n            self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires\n\n            self.on('end', function () {\n              // The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n              process.nextTick(function () {\n                self.emit('close');\n              });\n            });\n\n            if (mode === 'fetch') {\n              self._fetchResponse = response;\n              self.url = response.url;\n              self.statusCode = response.status;\n              self.statusMessage = response.statusText;\n              response.headers.forEach(function (header, key) {\n                self.headers[key.toLowerCase()] = header;\n                self.rawHeaders.push(key, header);\n              });\n\n              if (capability.writableStream) {\n                var writable = new WritableStream({\n                  write: function (chunk) {\n                    return new Promise(function (resolve, reject) {\n                      if (self._destroyed) {\n                        reject();\n                      } else if (self.push(Buffer.from(chunk))) {\n                        resolve();\n                      } else {\n                        self._resumeFetch = resolve;\n                      }\n                    });\n                  },\n                  close: function () {\n                    __nested_webpack_require_144445__.g.clearTimeout(fetchTimer);\n\n                    if (!self._destroyed) self.push(null);\n                  },\n                  abort: function (err) {\n                    if (!self._destroyed) self.emit('error', err);\n                  }\n                });\n\n                try {\n                  response.body.pipeTo(writable).catch(function (err) {\n                    __nested_webpack_require_144445__.g.clearTimeout(fetchTimer);\n\n                    if (!self._destroyed) self.emit('error', err);\n                  });\n                  return;\n                } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\n              } // fallback for when writableStream or pipeTo aren't available\n\n\n              var reader = response.body.getReader();\n\n              function read() {\n                reader.read().then(function (result) {\n                  if (self._destroyed) return;\n\n                  if (result.done) {\n                    __nested_webpack_require_144445__.g.clearTimeout(fetchTimer);\n\n                    self.push(null);\n                    return;\n                  }\n\n                  self.push(Buffer.from(result.value));\n                  read();\n                }).catch(function (err) {\n                  __nested_webpack_require_144445__.g.clearTimeout(fetchTimer);\n\n                  if (!self._destroyed) self.emit('error', err);\n                });\n              }\n\n              read();\n            } else {\n              self._xhr = xhr;\n              self._pos = 0;\n              self.url = xhr.responseURL;\n              self.statusCode = xhr.status;\n              self.statusMessage = xhr.statusText;\n              var headers = xhr.getAllResponseHeaders().split(/\\r?\\n/);\n              headers.forEach(function (header) {\n                var matches = header.match(/^([^:]+):\\s*(.*)/);\n\n                if (matches) {\n                  var key = matches[1].toLowerCase();\n\n                  if (key === 'set-cookie') {\n                    if (self.headers[key] === undefined) {\n                      self.headers[key] = [];\n                    }\n\n                    self.headers[key].push(matches[2]);\n                  } else if (self.headers[key] !== undefined) {\n                    self.headers[key] += ', ' + matches[2];\n                  } else {\n                    self.headers[key] = matches[2];\n                  }\n\n                  self.rawHeaders.push(matches[1], matches[2]);\n                }\n              });\n              self._charset = 'x-user-defined';\n\n              if (!capability.overrideMimeType) {\n                var mimeType = self.rawHeaders['mime-type'];\n\n                if (mimeType) {\n                  var charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/);\n\n                  if (charsetMatch) {\n                    self._charset = charsetMatch[1].toLowerCase();\n                  }\n                }\n\n                if (!self._charset) self._charset = 'utf-8'; // best guess\n              }\n            }\n          };\n\n          inherits(IncomingMessage, stream.Readable);\n\n          IncomingMessage.prototype._read = function () {\n            var self = this;\n            var resolve = self._resumeFetch;\n\n            if (resolve) {\n              self._resumeFetch = null;\n              resolve();\n            }\n          };\n\n          IncomingMessage.prototype._onXHRProgress = function () {\n            var self = this;\n            var xhr = self._xhr;\n            var response = null;\n\n            switch (self._mode) {\n              case 'text':\n                response = xhr.responseText;\n\n                if (response.length > self._pos) {\n                  var newData = response.substr(self._pos);\n\n                  if (self._charset === 'x-user-defined') {\n                    var buffer = Buffer.alloc(newData.length);\n\n                    for (var i = 0; i < newData.length; i++) buffer[i] = newData.charCodeAt(i) & 0xff;\n\n                    self.push(buffer);\n                  } else {\n                    self.push(newData, self._charset);\n                  }\n\n                  self._pos = response.length;\n                }\n\n                break;\n\n              case 'arraybuffer':\n                if (xhr.readyState !== rStates.DONE || !xhr.response) break;\n                response = xhr.response;\n                self.push(Buffer.from(new Uint8Array(response)));\n                break;\n\n              case 'moz-chunked-arraybuffer':\n                // take whole\n                response = xhr.response;\n                if (xhr.readyState !== rStates.LOADING || !response) break;\n                self.push(Buffer.from(new Uint8Array(response)));\n                break;\n\n              case 'ms-stream':\n                response = xhr.response;\n                if (xhr.readyState !== rStates.LOADING) break;\n                var reader = new __nested_webpack_require_144445__.g.MSStreamReader();\n\n                reader.onprogress = function () {\n                  if (reader.result.byteLength > self._pos) {\n                    self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));\n                    self._pos = reader.result.byteLength;\n                  }\n                };\n\n                reader.onload = function () {\n                  self.push(null);\n                }; // reader.onerror = ??? // TODO: this\n\n\n                reader.readAsArrayBuffer(response);\n                break;\n            } // The ms-stream case handles end separately in reader.onload()\n\n\n            if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n              self.push(null);\n            }\n          };\n          /***/\n\n        },\n\n        /***/\n        303:\n        /***/\n        module => {\n          \"use strict\";\n\n          function _inheritsLoose(subClass, superClass) {\n            subClass.prototype = Object.create(superClass.prototype);\n            subClass.prototype.constructor = subClass;\n            subClass.__proto__ = superClass;\n          }\n\n          var codes = {};\n\n          function createErrorType(code, message, Base) {\n            if (!Base) {\n              Base = Error;\n            }\n\n            function getMessage(arg1, arg2, arg3) {\n              if (typeof message === 'string') {\n                return message;\n              } else {\n                return message(arg1, arg2, arg3);\n              }\n            }\n\n            var NodeError = /*#__PURE__*/function (_Base) {\n              _inheritsLoose(NodeError, _Base);\n\n              function NodeError(arg1, arg2, arg3) {\n                return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;\n              }\n\n              return NodeError;\n            }(Base);\n\n            NodeError.prototype.name = Base.name;\n            NodeError.prototype.code = code;\n            codes[code] = NodeError;\n          } // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js\n\n\n          function oneOf(expected, thing) {\n            if (Array.isArray(expected)) {\n              var len = expected.length;\n              expected = expected.map(function (i) {\n                return String(i);\n              });\n\n              if (len > 2) {\n                return \"one of \".concat(thing, \" \").concat(expected.slice(0, len - 1).join(', '), \", or \") + expected[len - 1];\n              } else if (len === 2) {\n                return \"one of \".concat(thing, \" \").concat(expected[0], \" or \").concat(expected[1]);\n              } else {\n                return \"of \".concat(thing, \" \").concat(expected[0]);\n              }\n            } else {\n              return \"of \".concat(thing, \" \").concat(String(expected));\n            }\n          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith\n\n\n          function startsWith(str, search, pos) {\n            return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;\n          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith\n\n\n          function endsWith(str, search, this_len) {\n            if (this_len === undefined || this_len > str.length) {\n              this_len = str.length;\n            }\n\n            return str.substring(this_len - search.length, this_len) === search;\n          } // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes\n\n\n          function includes(str, search, start) {\n            if (typeof start !== 'number') {\n              start = 0;\n            }\n\n            if (start + search.length > str.length) {\n              return false;\n            } else {\n              return str.indexOf(search, start) !== -1;\n            }\n          }\n\n          createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {\n            return 'The value \"' + value + '\" is invalid for option \"' + name + '\"';\n          }, TypeError);\n          createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {\n            // determiner: 'must be' or 'must not be'\n            var determiner;\n\n            if (typeof expected === 'string' && startsWith(expected, 'not ')) {\n              determiner = 'must not be';\n              expected = expected.replace(/^not /, '');\n            } else {\n              determiner = 'must be';\n            }\n\n            var msg;\n\n            if (endsWith(name, ' argument')) {\n              // For cases like 'first argument'\n              msg = \"The \".concat(name, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n            } else {\n              var type = includes(name, '.') ? 'property' : 'argument';\n              msg = \"The \\\"\".concat(name, \"\\\" \").concat(type, \" \").concat(determiner, \" \").concat(oneOf(expected, 'type'));\n            }\n\n            msg += \". Received type \".concat(typeof actual);\n            return msg;\n          }, TypeError);\n          createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');\n          createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {\n            return 'The ' + name + ' method is not implemented';\n          });\n          createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');\n          createErrorType('ERR_STREAM_DESTROYED', function (name) {\n            return 'Cannot call ' + name + ' after a stream was destroyed';\n          });\n          createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');\n          createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');\n          createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');\n          createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);\n          createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {\n            return 'Unknown encoding: ' + arg;\n          }, TypeError);\n          createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');\n          module.exports.q = codes;\n          /***/\n        },\n\n        /***/\n        560:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_157669__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // a duplex stream is just a stream that is both readable and writable.\n          // Since JS doesn't have multiple prototypal inheritance, this class\n          // prototypally inherits from Readable, and then parasitically from\n          // Writable.\n\n          /*<replacement>*/\n\n          var objectKeys = Object.keys || function (obj) {\n            var keys = [];\n\n            for (var key in obj) {\n              keys.push(key);\n            }\n\n            return keys;\n          };\n          /*</replacement>*/\n\n\n          module.exports = Duplex;\n\n          var Readable = __nested_webpack_require_157669__(2);\n\n          var Writable = __nested_webpack_require_157669__(313);\n\n          __nested_webpack_require_157669__(717)(Duplex, Readable);\n\n          {\n            // Allow the keys array to be GC'ed.\n            var keys = objectKeys(Writable.prototype);\n\n            for (var v = 0; v < keys.length; v++) {\n              var method = keys[v];\n              if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n            }\n          }\n\n          function Duplex(options) {\n            if (!(this instanceof Duplex)) return new Duplex(options);\n            Readable.call(this, options);\n            Writable.call(this, options);\n            this.allowHalfOpen = true;\n\n            if (options) {\n              if (options.readable === false) this.readable = false;\n              if (options.writable === false) this.writable = false;\n\n              if (options.allowHalfOpen === false) {\n                this.allowHalfOpen = false;\n                this.once('end', onend);\n              }\n            }\n          }\n\n          Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n          Object.defineProperty(Duplex.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          }); // the no-half-open enforcer\n\n          function onend() {\n            // If the writable side ended, then we're ok.\n            if (this._writableState.ended) return; // no more data can be written.\n            // But allow more writes to happen in this tick.\n\n            process.nextTick(onEndNT, this);\n          }\n\n          function onEndNT(self) {\n            self.end();\n          }\n\n          Object.defineProperty(Duplex.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed && this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (this._readableState === undefined || this._writableState === undefined) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n              this._writableState.destroyed = value;\n            }\n          });\n          /***/\n        },\n\n        /***/\n        842:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_163371__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // a passthrough stream.\n          // basically just the most minimal sort of Transform stream.\n          // Every written chunk gets output as-is.\n\n          module.exports = PassThrough;\n\n          var Transform = __nested_webpack_require_163371__(846);\n\n          __nested_webpack_require_163371__(717)(PassThrough, Transform);\n\n          function PassThrough(options) {\n            if (!(this instanceof PassThrough)) return new PassThrough(options);\n            Transform.call(this, options);\n          }\n\n          PassThrough.prototype._transform = function (chunk, encoding, cb) {\n            cb(null, chunk);\n          };\n          /***/\n\n        },\n\n        /***/\n        2:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_165468__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n          module.exports = Readable;\n          /*<replacement>*/\n\n          var Duplex;\n          /*</replacement>*/\n\n          Readable.ReadableState = ReadableState;\n          /*<replacement>*/\n\n          var EE = __nested_webpack_require_165468__(187).EventEmitter;\n\n          var EElistenerCount = function EElistenerCount(emitter, type) {\n            return emitter.listeners(type).length;\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n\n          var Stream = __nested_webpack_require_165468__(463);\n          /*</replacement>*/\n\n\n          var Buffer = __nested_webpack_require_165468__(764).Buffer;\n\n          var OurUint8Array = __nested_webpack_require_165468__.g.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n          /*<replacement>*/\n\n\n          var debugUtil = __nested_webpack_require_165468__(758);\n\n          var debug;\n\n          if (debugUtil && debugUtil.debuglog) {\n            debug = debugUtil.debuglog('stream');\n          } else {\n            debug = function debug() {};\n          }\n          /*</replacement>*/\n\n\n          var BufferList = __nested_webpack_require_165468__(641);\n\n          var destroyImpl = __nested_webpack_require_165468__(369);\n\n          var _require = __nested_webpack_require_165468__(624),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = __nested_webpack_require_165468__(303)\n          /* .codes */\n          .q,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.\n\n\n          var StringDecoder;\n          var createReadableStreamAsyncIterator;\n          var from;\n\n          __nested_webpack_require_165468__(717)(Readable, Stream);\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n          var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\n          function prependListener(emitter, event, fn) {\n            // Sadly this is not cacheable as some libraries bundle their own\n            // event emitter implementation with them.\n            if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any\n            // userland ones.  NEVER DO THIS. This is here only because this code needs\n            // to continue to work with older versions of Node.js that do not include\n            // the prependListener() method. The goal is to eventually remove this hack.\n\n            if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n          }\n\n          function ReadableState(options, stream, isDuplex) {\n            Duplex = Duplex || __nested_webpack_require_165468__(560);\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream.\n            // These options can be provided separately as readableXXX and writableXXX.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to\n            // make all the buffer merging and length checks go away\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer\n            // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n\n            this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the\n            // linked list can remove elements from the beginning faster than\n            // array.shift()\n\n            this.buffer = new BufferList();\n            this.length = 0;\n            this.pipes = null;\n            this.pipesCount = 0;\n            this.flowing = null;\n            this.ended = false;\n            this.endEmitted = false;\n            this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted\n            // immediately, or on a later tick.  We set this to true at first, because\n            // any actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first read call.\n\n            this.sync = true; // whenever we return null, then we set a flag to say\n            // that we're awaiting a 'readable' event emission.\n\n            this.needReadable = false;\n            this.emittedReadable = false;\n            this.readableListening = false;\n            this.resumeScheduled = false;\n            this.paused = true; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')\n\n            this.autoDestroy = !!options.autoDestroy; // has it been destroyed\n\n            this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s\n\n            this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled\n\n            this.readingMore = false;\n            this.decoder = null;\n            this.encoding = null;\n\n            if (options.encoding) {\n              if (!StringDecoder) StringDecoder = __nested_webpack_require_165468__(553)\n              /* .StringDecoder */\n              .s;\n              this.decoder = new StringDecoder(options.encoding);\n              this.encoding = options.encoding;\n            }\n          }\n\n          function Readable(options) {\n            Duplex = Duplex || __nested_webpack_require_165468__(560);\n            if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the ReadableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            this._readableState = new ReadableState(options, this, isDuplex); // legacy\n\n            this.readable = true;\n\n            if (options) {\n              if (typeof options.read === 'function') this._read = options.read;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n            }\n\n            Stream.call(this);\n          }\n\n          Object.defineProperty(Readable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._readableState === undefined) {\n                return false;\n              }\n\n              return this._readableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._readableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._readableState.destroyed = value;\n            }\n          });\n          Readable.prototype.destroy = destroyImpl.destroy;\n          Readable.prototype._undestroy = destroyImpl.undestroy;\n\n          Readable.prototype._destroy = function (err, cb) {\n            cb(err);\n          }; // Manually shove something into the read() buffer.\n          // This returns true if the highWaterMark has not been hit yet,\n          // similar to how Writable.write() returns true if you should\n          // write() some more.\n\n\n          Readable.prototype.push = function (chunk, encoding) {\n            var state = this._readableState;\n            var skipChunkCheck;\n\n            if (!state.objectMode) {\n              if (typeof chunk === 'string') {\n                encoding = encoding || state.defaultEncoding;\n\n                if (encoding !== state.encoding) {\n                  chunk = Buffer.from(chunk, encoding);\n                  encoding = '';\n                }\n\n                skipChunkCheck = true;\n              }\n            } else {\n              skipChunkCheck = true;\n            }\n\n            return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n          }; // Unshift should *always* be something directly out of read()\n\n\n          Readable.prototype.unshift = function (chunk) {\n            return readableAddChunk(this, chunk, null, true, false);\n          };\n\n          function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n            debug('readableAddChunk', chunk);\n            var state = stream._readableState;\n\n            if (chunk === null) {\n              state.reading = false;\n              onEofChunk(stream, state);\n            } else {\n              var er;\n              if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n\n              if (er) {\n                errorOrDestroy(stream, er);\n              } else if (state.objectMode || chunk && chunk.length > 0) {\n                if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n                  chunk = _uint8ArrayToBuffer(chunk);\n                }\n\n                if (addToFront) {\n                  if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);\n                } else if (state.ended) {\n                  errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());\n                } else if (state.destroyed) {\n                  return false;\n                } else {\n                  state.reading = false;\n\n                  if (state.decoder && !encoding) {\n                    chunk = state.decoder.write(chunk);\n                    if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n                  } else {\n                    addChunk(stream, state, chunk, false);\n                  }\n                }\n              } else if (!addToFront) {\n                state.reading = false;\n                maybeReadMore(stream, state);\n              }\n            } // We can push more data if we are below the highWaterMark.\n            // Also, if we have no data yet, we can stand some more bytes.\n            // This is to work around cases where hwm=0, such as the repl.\n\n\n            return !state.ended && (state.length < state.highWaterMark || state.length === 0);\n          }\n\n          function addChunk(stream, state, chunk, addToFront) {\n            if (state.flowing && state.length === 0 && !state.sync) {\n              state.awaitDrain = 0;\n              stream.emit('data', chunk);\n            } else {\n              // update the buffer info.\n              state.length += state.objectMode ? 1 : chunk.length;\n              if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n              if (state.needReadable) emitReadable(stream);\n            }\n\n            maybeReadMore(stream, state);\n          }\n\n          function chunkInvalid(state, chunk) {\n            var er;\n\n            if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);\n            }\n\n            return er;\n          }\n\n          Readable.prototype.isPaused = function () {\n            return this._readableState.flowing === false;\n          }; // backwards compatibility.\n\n\n          Readable.prototype.setEncoding = function (enc) {\n            if (!StringDecoder) StringDecoder = __nested_webpack_require_165468__(553)\n            /* .StringDecoder */\n            .s;\n            var decoder = new StringDecoder(enc);\n            this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8\n\n            this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:\n\n            var p = this._readableState.buffer.head;\n            var content = '';\n\n            while (p !== null) {\n              content += decoder.write(p.data);\n              p = p.next;\n            }\n\n            this._readableState.buffer.clear();\n\n            if (content !== '') this._readableState.buffer.push(content);\n            this._readableState.length = content.length;\n            return this;\n          }; // Don't raise the hwm > 1GB\n\n\n          var MAX_HWM = 0x40000000;\n\n          function computeNewHighWaterMark(n) {\n            if (n >= MAX_HWM) {\n              // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.\n              n = MAX_HWM;\n            } else {\n              // Get the next highest power of 2 to prevent increasing hwm excessively in\n              // tiny amounts\n              n--;\n              n |= n >>> 1;\n              n |= n >>> 2;\n              n |= n >>> 4;\n              n |= n >>> 8;\n              n |= n >>> 16;\n              n++;\n            }\n\n            return n;\n          } // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n\n          function howMuchToRead(n, state) {\n            if (n <= 0 || state.length === 0 && state.ended) return 0;\n            if (state.objectMode) return 1;\n\n            if (n !== n) {\n              // Only flow one buffer at a time\n              if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n            } // If we're asking for more than the current hwm, then raise the hwm.\n\n\n            if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n            if (n <= state.length) return n; // Don't have enough\n\n            if (!state.ended) {\n              state.needReadable = true;\n              return 0;\n            }\n\n            return state.length;\n          } // you can override either this method, or the async _read(n) below.\n\n\n          Readable.prototype.read = function (n) {\n            debug('read', n);\n            n = parseInt(n, 10);\n            var state = this._readableState;\n            var nOrig = n;\n            if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we\n            // already have a bunch of data in the buffer, then just trigger\n            // the 'readable' event and move on.\n\n            if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {\n              debug('read: emitReadable', state.length, state.ended);\n              if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n              return null;\n            }\n\n            n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.\n\n            if (n === 0 && state.ended) {\n              if (state.length === 0) endReadable(this);\n              return null;\n            } // All the actual chunk generation logic needs to be\n            // *below* the call to _read.  The reason is that in certain\n            // synthetic stream cases, such as passthrough streams, _read\n            // may be a completely synchronous operation which may change\n            // the state of the read buffer, providing enough data when\n            // before there was *not* enough.\n            //\n            // So, the steps are:\n            // 1. Figure out what the state of things will be after we do\n            // a read from the buffer.\n            //\n            // 2. If that resulting state will trigger a _read, then call _read.\n            // Note that this may be asynchronous, or synchronous.  Yes, it is\n            // deeply ugly to write APIs this way, but that still doesn't mean\n            // that the Readable class should behave improperly, as streams are\n            // designed to be sync/async agnostic.\n            // Take note if the _read call is sync or async (ie, if the read call\n            // has returned yet), so that we know whether or not it's safe to emit\n            // 'readable' etc.\n            //\n            // 3. Actually pull the requested chunks out of the buffer and return.\n            // if we need a readable event, then we need to do some reading.\n\n\n            var doRead = state.needReadable;\n            debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some\n\n            if (state.length === 0 || state.length - n < state.highWaterMark) {\n              doRead = true;\n              debug('length less than watermark', doRead);\n            } // however, if we've ended, then there's no point, and if we're already\n            // reading, then it's unnecessary.\n\n\n            if (state.ended || state.reading) {\n              doRead = false;\n              debug('reading or ended', doRead);\n            } else if (doRead) {\n              debug('do read');\n              state.reading = true;\n              state.sync = true; // if the length is currently zero, then we *need* a readable event.\n\n              if (state.length === 0) state.needReadable = true; // call internal read method\n\n              this._read(state.highWaterMark);\n\n              state.sync = false; // If _read pushed data synchronously, then `reading` will be false,\n              // and we need to re-evaluate how much data we can return to the user.\n\n              if (!state.reading) n = howMuchToRead(nOrig, state);\n            }\n\n            var ret;\n            if (n > 0) ret = fromList(n, state);else ret = null;\n\n            if (ret === null) {\n              state.needReadable = state.length <= state.highWaterMark;\n              n = 0;\n            } else {\n              state.length -= n;\n              state.awaitDrain = 0;\n            }\n\n            if (state.length === 0) {\n              // If we have nothing in the buffer, then we want to know\n              // as soon as we *do* get something into the buffer.\n              if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.\n\n              if (nOrig !== n && state.ended) endReadable(this);\n            }\n\n            if (ret !== null) this.emit('data', ret);\n            return ret;\n          };\n\n          function onEofChunk(stream, state) {\n            debug('onEofChunk');\n            if (state.ended) return;\n\n            if (state.decoder) {\n              var chunk = state.decoder.end();\n\n              if (chunk && chunk.length) {\n                state.buffer.push(chunk);\n                state.length += state.objectMode ? 1 : chunk.length;\n              }\n            }\n\n            state.ended = true;\n\n            if (state.sync) {\n              // if we are sync, wait until next tick to emit the data.\n              // Otherwise we risk emitting data in the flow()\n              // the readable code triggers during a read() call\n              emitReadable(stream);\n            } else {\n              // emit 'readable' now to make sure it gets picked up.\n              state.needReadable = false;\n\n              if (!state.emittedReadable) {\n                state.emittedReadable = true;\n                emitReadable_(stream);\n              }\n            }\n          } // Don't emit readable right away in sync mode, because this can trigger\n          // another read() call => stack overflow.  This way, it might trigger\n          // a nextTick recursion warning, but that's not so bad.\n\n\n          function emitReadable(stream) {\n            var state = stream._readableState;\n            debug('emitReadable', state.needReadable, state.emittedReadable);\n            state.needReadable = false;\n\n            if (!state.emittedReadable) {\n              debug('emitReadable', state.flowing);\n              state.emittedReadable = true;\n              process.nextTick(emitReadable_, stream);\n            }\n          }\n\n          function emitReadable_(stream) {\n            var state = stream._readableState;\n            debug('emitReadable_', state.destroyed, state.length, state.ended);\n\n            if (!state.destroyed && (state.length || state.ended)) {\n              stream.emit('readable');\n              state.emittedReadable = false;\n            } // The stream needs another readable event if\n            // 1. It is not flowing, as the flow mechanism will take\n            //    care of it.\n            // 2. It is not ended.\n            // 3. It is below the highWaterMark, so we can schedule\n            //    another readable later.\n\n\n            state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;\n            flow(stream);\n          } // at this point, the user has presumably seen the 'readable' event,\n          // and called read() to consume some data.  that may have triggered\n          // in turn another _read(n) call, in which case reading = true if\n          // it's in progress.\n          // However, if we're not ended, or reading, and the length < hwm,\n          // then go ahead and try to read some more preemptively.\n\n\n          function maybeReadMore(stream, state) {\n            if (!state.readingMore) {\n              state.readingMore = true;\n              process.nextTick(maybeReadMore_, stream, state);\n            }\n          }\n\n          function maybeReadMore_(stream, state) {\n            // Attempt to read more data if we should.\n            //\n            // The conditions for reading more data are (one of):\n            // - Not enough data buffered (state.length < state.highWaterMark). The loop\n            //   is responsible for filling the buffer with enough data if such data\n            //   is available. If highWaterMark is 0 and we are not in the flowing mode\n            //   we should _not_ attempt to buffer any extra data. We'll get more data\n            //   when the stream consumer calls read() instead.\n            // - No data in the buffer, and the stream is in flowing mode. In this mode\n            //   the loop below is responsible for ensuring read() is called. Failing to\n            //   call read here would abort the flow and there's no other mechanism for\n            //   continuing the flow if the stream consumer has just subscribed to the\n            //   'data' event.\n            //\n            // In addition to the above conditions to keep reading data, the following\n            // conditions prevent the data from being read:\n            // - The stream has ended (state.ended).\n            // - There is already a pending 'read' operation (state.reading). This is a\n            //   case where the the stream has called the implementation defined _read()\n            //   method, but they are processing the call asynchronously and have _not_\n            //   called push() with new data. In this case we skip performing more\n            //   read()s. The execution ends in this method again after the _read() ends\n            //   up calling push() with more data.\n            while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {\n              var len = state.length;\n              debug('maybeReadMore read 0');\n              stream.read(0);\n              if (len === state.length) // didn't get any data, stop spinning.\n                break;\n            }\n\n            state.readingMore = false;\n          } // abstract method.  to be overridden in specific implementation classes.\n          // call cb(er, data) where data is <= n in length.\n          // for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n          // arbitrary, and perhaps not very meaningful.\n\n\n          Readable.prototype._read = function (n) {\n            errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));\n          };\n\n          Readable.prototype.pipe = function (dest, pipeOpts) {\n            var src = this;\n            var state = this._readableState;\n\n            switch (state.pipesCount) {\n              case 0:\n                state.pipes = dest;\n                break;\n\n              case 1:\n                state.pipes = [state.pipes, dest];\n                break;\n\n              default:\n                state.pipes.push(dest);\n                break;\n            }\n\n            state.pipesCount += 1;\n            debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n            var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n            var endFn = doEnd ? onend : unpipe;\n            if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);\n            dest.on('unpipe', onunpipe);\n\n            function onunpipe(readable, unpipeInfo) {\n              debug('onunpipe');\n\n              if (readable === src) {\n                if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n                  unpipeInfo.hasUnpiped = true;\n                  cleanup();\n                }\n              }\n            }\n\n            function onend() {\n              debug('onend');\n              dest.end();\n            } // when the dest drains, it reduces the awaitDrain counter\n            // on the source.  This would be more elegant with a .once()\n            // handler in flow(), but adding and removing repeatedly is\n            // too slow.\n\n\n            var ondrain = pipeOnDrain(src);\n            dest.on('drain', ondrain);\n            var cleanedUp = false;\n\n            function cleanup() {\n              debug('cleanup'); // cleanup event handlers once the pipe is broken\n\n              dest.removeListener('close', onclose);\n              dest.removeListener('finish', onfinish);\n              dest.removeListener('drain', ondrain);\n              dest.removeListener('error', onerror);\n              dest.removeListener('unpipe', onunpipe);\n              src.removeListener('end', onend);\n              src.removeListener('end', unpipe);\n              src.removeListener('data', ondata);\n              cleanedUp = true; // if the reader is waiting for a drain event from this\n              // specific writer, then it would cause it to never start\n              // flowing again.\n              // So, if this is awaiting a drain, then we just call it now.\n              // If we don't know, then assume that we are waiting for one.\n\n              if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n            }\n\n            src.on('data', ondata);\n\n            function ondata(chunk) {\n              debug('ondata');\n              var ret = dest.write(chunk);\n              debug('dest.write', ret);\n\n              if (ret === false) {\n                // If the user unpiped during `dest.write()`, it is possible\n                // to get stuck in a permanently paused state if that write\n                // also returned false.\n                // => Check whether `dest` is still a piping destination.\n                if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n                  debug('false write response, pause', state.awaitDrain);\n                  state.awaitDrain++;\n                }\n\n                src.pause();\n              }\n            } // if the dest has an error, then stop piping into it.\n            // however, don't suppress the throwing behavior for this.\n\n\n            function onerror(er) {\n              debug('onerror', er);\n              unpipe();\n              dest.removeListener('error', onerror);\n              if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);\n            } // Make sure our error handler is attached before userland ones.\n\n\n            prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.\n\n            function onclose() {\n              dest.removeListener('finish', onfinish);\n              unpipe();\n            }\n\n            dest.once('close', onclose);\n\n            function onfinish() {\n              debug('onfinish');\n              dest.removeListener('close', onclose);\n              unpipe();\n            }\n\n            dest.once('finish', onfinish);\n\n            function unpipe() {\n              debug('unpipe');\n              src.unpipe(dest);\n            } // tell the dest that it's being piped to\n\n\n            dest.emit('pipe', src); // start the flow if it hasn't been started already.\n\n            if (!state.flowing) {\n              debug('pipe resume');\n              src.resume();\n            }\n\n            return dest;\n          };\n\n          function pipeOnDrain(src) {\n            return function pipeOnDrainFunctionResult() {\n              var state = src._readableState;\n              debug('pipeOnDrain', state.awaitDrain);\n              if (state.awaitDrain) state.awaitDrain--;\n\n              if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n                state.flowing = true;\n                flow(src);\n              }\n            };\n          }\n\n          Readable.prototype.unpipe = function (dest) {\n            var state = this._readableState;\n            var unpipeInfo = {\n              hasUnpiped: false\n            }; // if we're not piping anywhere, then do nothing.\n\n            if (state.pipesCount === 0) return this; // just one destination.  most common case.\n\n            if (state.pipesCount === 1) {\n              // passed in one, but it's not the right one.\n              if (dest && dest !== state.pipes) return this;\n              if (!dest) dest = state.pipes; // got a match.\n\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n              if (dest) dest.emit('unpipe', this, unpipeInfo);\n              return this;\n            } // slow case. multiple pipe destinations.\n\n\n            if (!dest) {\n              // remove all.\n              var dests = state.pipes;\n              var len = state.pipesCount;\n              state.pipes = null;\n              state.pipesCount = 0;\n              state.flowing = false;\n\n              for (var i = 0; i < len; i++) {\n                dests[i].emit('unpipe', this, {\n                  hasUnpiped: false\n                });\n              }\n\n              return this;\n            } // try to find the right one.\n\n\n            var index = indexOf(state.pipes, dest);\n            if (index === -1) return this;\n            state.pipes.splice(index, 1);\n            state.pipesCount -= 1;\n            if (state.pipesCount === 1) state.pipes = state.pipes[0];\n            dest.emit('unpipe', this, unpipeInfo);\n            return this;\n          }; // set up data events if they are asked for\n          // Ensure readable listeners eventually get something\n\n\n          Readable.prototype.on = function (ev, fn) {\n            var res = Stream.prototype.on.call(this, ev, fn);\n            var state = this._readableState;\n\n            if (ev === 'data') {\n              // update readableListening so that resume() may be a no-op\n              // a few lines down. This is needed to support once('readable').\n              state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused\n\n              if (state.flowing !== false) this.resume();\n            } else if (ev === 'readable') {\n              if (!state.endEmitted && !state.readableListening) {\n                state.readableListening = state.needReadable = true;\n                state.flowing = false;\n                state.emittedReadable = false;\n                debug('on readable', state.length, state.reading);\n\n                if (state.length) {\n                  emitReadable(this);\n                } else if (!state.reading) {\n                  process.nextTick(nReadingNextTick, this);\n                }\n              }\n            }\n\n            return res;\n          };\n\n          Readable.prototype.addListener = Readable.prototype.on;\n\n          Readable.prototype.removeListener = function (ev, fn) {\n            var res = Stream.prototype.removeListener.call(this, ev, fn);\n\n            if (ev === 'readable') {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          Readable.prototype.removeAllListeners = function (ev) {\n            var res = Stream.prototype.removeAllListeners.apply(this, arguments);\n\n            if (ev === 'readable' || ev === undefined) {\n              // We need to check if there is someone still listening to\n              // readable and reset the state. However this needs to happen\n              // after readable has been emitted but before I/O (nextTick) to\n              // support once('readable', fn) cycles. This means that calling\n              // resume within the same tick will have no\n              // effect.\n              process.nextTick(updateReadableListening, this);\n            }\n\n            return res;\n          };\n\n          function updateReadableListening(self) {\n            var state = self._readableState;\n            state.readableListening = self.listenerCount('readable') > 0;\n\n            if (state.resumeScheduled && !state.paused) {\n              // flowing needs to be set to true now, otherwise\n              // the upcoming resume will not flow.\n              state.flowing = true; // crude way to check if we should resume\n            } else if (self.listenerCount('data') > 0) {\n              self.resume();\n            }\n          }\n\n          function nReadingNextTick(self) {\n            debug('readable nexttick read 0');\n            self.read(0);\n          } // pause() and resume() are remnants of the legacy readable stream API\n          // If the user uses them, then switch into old mode.\n\n\n          Readable.prototype.resume = function () {\n            var state = this._readableState;\n\n            if (!state.flowing) {\n              debug('resume'); // we flow only if there is no one listening\n              // for readable, but we still have to call\n              // resume()\n\n              state.flowing = !state.readableListening;\n              resume(this, state);\n            }\n\n            state.paused = false;\n            return this;\n          };\n\n          function resume(stream, state) {\n            if (!state.resumeScheduled) {\n              state.resumeScheduled = true;\n              process.nextTick(resume_, stream, state);\n            }\n          }\n\n          function resume_(stream, state) {\n            debug('resume', state.reading);\n\n            if (!state.reading) {\n              stream.read(0);\n            }\n\n            state.resumeScheduled = false;\n            stream.emit('resume');\n            flow(stream);\n            if (state.flowing && !state.reading) stream.read(0);\n          }\n\n          Readable.prototype.pause = function () {\n            debug('call pause flowing=%j', this._readableState.flowing);\n\n            if (this._readableState.flowing !== false) {\n              debug('pause');\n              this._readableState.flowing = false;\n              this.emit('pause');\n            }\n\n            this._readableState.paused = true;\n            return this;\n          };\n\n          function flow(stream) {\n            var state = stream._readableState;\n            debug('flow', state.flowing);\n\n            while (state.flowing && stream.read() !== null) {\n              ;\n            }\n          } // wrap an old-style stream as the async data source.\n          // This is *not* part of the readable stream interface.\n          // It is an ugly unfortunate mess of history.\n\n\n          Readable.prototype.wrap = function (stream) {\n            var _this = this;\n\n            var state = this._readableState;\n            var paused = false;\n            stream.on('end', function () {\n              debug('wrapped end');\n\n              if (state.decoder && !state.ended) {\n                var chunk = state.decoder.end();\n                if (chunk && chunk.length) _this.push(chunk);\n              }\n\n              _this.push(null);\n            });\n            stream.on('data', function (chunk) {\n              debug('wrapped data');\n              if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode\n\n              if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n              var ret = _this.push(chunk);\n\n              if (!ret) {\n                paused = true;\n                stream.pause();\n              }\n            }); // proxy all the other methods.\n            // important when wrapping filters and duplexes.\n\n            for (var i in stream) {\n              if (this[i] === undefined && typeof stream[i] === 'function') {\n                this[i] = function methodWrap(method) {\n                  return function methodWrapReturnFunction() {\n                    return stream[method].apply(stream, arguments);\n                  };\n                }(i);\n              }\n            } // proxy certain important events.\n\n\n            for (var n = 0; n < kProxyEvents.length; n++) {\n              stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n            } // when we try to consume some more bytes, simply unpause the\n            // underlying stream.\n\n\n            this._read = function (n) {\n              debug('wrapped _read', n);\n\n              if (paused) {\n                paused = false;\n                stream.resume();\n              }\n            };\n\n            return this;\n          };\n\n          if (typeof Symbol === 'function') {\n            Readable.prototype[Symbol.asyncIterator] = function () {\n              if (createReadableStreamAsyncIterator === undefined) {\n                createReadableStreamAsyncIterator = __nested_webpack_require_165468__(819);\n              }\n\n              return createReadableStreamAsyncIterator(this);\n            };\n          }\n\n          Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.highWaterMark;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState && this._readableState.buffer;\n            }\n          });\n          Object.defineProperty(Readable.prototype, 'readableFlowing', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.flowing;\n            },\n            set: function set(state) {\n              if (this._readableState) {\n                this._readableState.flowing = state;\n              }\n            }\n          }); // exposed for testing purposes only.\n\n          Readable._fromList = fromList;\n          Object.defineProperty(Readable.prototype, 'readableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._readableState.length;\n            }\n          }); // Pluck off n bytes from an array of buffers.\n          // Length is the combined lengths of all the buffers in the list.\n          // This function is designed to be inlinable, so please take care when making\n          // changes to the function body.\n\n          function fromList(n, state) {\n            // nothing buffered\n            if (state.length === 0) return null;\n            var ret;\n            if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n              // read it all, truncate the list\n              if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);\n              state.buffer.clear();\n            } else {\n              // read part of list\n              ret = state.buffer.consume(n, state.decoder);\n            }\n            return ret;\n          }\n\n          function endReadable(stream) {\n            var state = stream._readableState;\n            debug('endReadable', state.endEmitted);\n\n            if (!state.endEmitted) {\n              state.ended = true;\n              process.nextTick(endReadableNT, state, stream);\n            }\n          }\n\n          function endReadableNT(state, stream) {\n            debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.\n\n            if (!state.endEmitted && state.length === 0) {\n              state.endEmitted = true;\n              stream.readable = false;\n              stream.emit('end');\n\n              if (state.autoDestroy) {\n                // In case of duplex streams we need a way to detect\n                // if the writable side is ready for autoDestroy as well\n                var wState = stream._writableState;\n\n                if (!wState || wState.autoDestroy && wState.finished) {\n                  stream.destroy();\n                }\n              }\n            }\n          }\n\n          if (typeof Symbol === 'function') {\n            Readable.from = function (iterable, opts) {\n              if (from === undefined) {\n                from = __nested_webpack_require_165468__(869);\n              }\n\n              return from(Readable, iterable, opts);\n            };\n          }\n\n          function indexOf(xs, x) {\n            for (var i = 0, l = xs.length; i < l; i++) {\n              if (xs[i] === x) return i;\n            }\n\n            return -1;\n          }\n          /***/\n\n        },\n\n        /***/\n        846:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_210556__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // a transform stream is a readable/writable stream where you do\n          // something with the data.  Sometimes it's called a \"filter\",\n          // but that's not a great name for it, since that implies a thing where\n          // some bits pass through, and others are simply ignored.  (That would\n          // be a valid example of a transform, of course.)\n          //\n          // While the output is causally related to the input, it's not a\n          // necessarily symmetric or synchronous transformation.  For example,\n          // a zlib stream might take multiple plain-text writes(), and then\n          // emit a single compressed chunk some time in the future.\n          //\n          // Here's how this works:\n          //\n          // The Transform stream has all the aspects of the readable and writable\n          // stream classes.  When you write(chunk), that calls _write(chunk,cb)\n          // internally, and returns false if there's a lot of pending writes\n          // buffered up.  When you call read(), that calls _read(n) until\n          // there's enough pending readable data buffered up.\n          //\n          // In a transform stream, the written data is placed in a buffer.  When\n          // _read(n) is called, it transforms the queued up data, calling the\n          // buffered _write cb's as it consumes chunks.  If consuming a single\n          // written chunk would result in multiple output chunks, then the first\n          // outputted bit calls the readcb, and subsequent chunks just go into\n          // the read buffer, and will cause it to emit 'readable' if necessary.\n          //\n          // This way, back-pressure is actually determined by the reading side,\n          // since _read has to be called to start processing a new chunk.  However,\n          // a pathological inflate type of transform can cause excessive buffering\n          // here.  For example, imagine a stream where every byte of input is\n          // interpreted as an integer from 0-255, and then results in that many\n          // bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n          // 1kb of data being output.  In this case, you could write a very small\n          // amount of input, and end up with a very large amount of output.  In\n          // such a pathological inflating mechanism, there'd be no way to tell\n          // the system to stop doing the transform.  A single 4MB write could\n          // cause the system to run out of memory.\n          //\n          // However, even in such a pathological case, only a single written chunk\n          // would be consumed, and then the rest would wait (un-transformed) until\n          // the results of the previous transformed chunk were consumed.\n\n          module.exports = Transform;\n\n          var _require$codes = __nested_webpack_require_210556__(303)\n          /* .codes */\n          .q,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n              ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,\n              ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;\n\n          var Duplex = __nested_webpack_require_210556__(560);\n\n          __nested_webpack_require_210556__(717)(Transform, Duplex);\n\n          function afterTransform(er, data) {\n            var ts = this._transformState;\n            ts.transforming = false;\n            var cb = ts.writecb;\n\n            if (cb === null) {\n              return this.emit('error', new ERR_MULTIPLE_CALLBACK());\n            }\n\n            ts.writechunk = null;\n            ts.writecb = null;\n            if (data != null) // single equals check for both `null` and `undefined`\n              this.push(data);\n            cb(er);\n            var rs = this._readableState;\n            rs.reading = false;\n\n            if (rs.needReadable || rs.length < rs.highWaterMark) {\n              this._read(rs.highWaterMark);\n            }\n          }\n\n          function Transform(options) {\n            if (!(this instanceof Transform)) return new Transform(options);\n            Duplex.call(this, options);\n            this._transformState = {\n              afterTransform: afterTransform.bind(this),\n              needTransform: false,\n              transforming: false,\n              writecb: null,\n              writechunk: null,\n              writeencoding: null\n            }; // start out asking for a readable event once data is transformed.\n\n            this._readableState.needReadable = true; // we have implemented the _read method, and done the other things\n            // that Readable wants before the first _read call, so unset the\n            // sync guard flag.\n\n            this._readableState.sync = false;\n\n            if (options) {\n              if (typeof options.transform === 'function') this._transform = options.transform;\n              if (typeof options.flush === 'function') this._flush = options.flush;\n            } // When the writable side finishes, then flush out anything remaining.\n\n\n            this.on('prefinish', prefinish);\n          }\n\n          function prefinish() {\n            var _this = this;\n\n            if (typeof this._flush === 'function' && !this._readableState.destroyed) {\n              this._flush(function (er, data) {\n                done(_this, er, data);\n              });\n            } else {\n              done(this, null, null);\n            }\n          }\n\n          Transform.prototype.push = function (chunk, encoding) {\n            this._transformState.needTransform = false;\n            return Duplex.prototype.push.call(this, chunk, encoding);\n          }; // This is the part where you do stuff!\n          // override this function in implementation classes.\n          // 'chunk' is an input chunk.\n          //\n          // Call `push(newChunk)` to pass along transformed output\n          // to the readable side.  You may call 'push' zero or more times.\n          //\n          // Call `cb(err)` when you are done with this chunk.  If you pass\n          // an error, then that'll put the hurt on the whole operation.  If you\n          // never call cb(), then you'll never get another chunk.\n\n\n          Transform.prototype._transform = function (chunk, encoding, cb) {\n            cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));\n          };\n\n          Transform.prototype._write = function (chunk, encoding, cb) {\n            var ts = this._transformState;\n            ts.writecb = cb;\n            ts.writechunk = chunk;\n            ts.writeencoding = encoding;\n\n            if (!ts.transforming) {\n              var rs = this._readableState;\n              if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n            }\n          }; // Doesn't matter what the args are here.\n          // _transform does all the work.\n          // That we got here means that the readable side wants more data.\n\n\n          Transform.prototype._read = function (n) {\n            var ts = this._transformState;\n\n            if (ts.writechunk !== null && !ts.transforming) {\n              ts.transforming = true;\n\n              this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n            } else {\n              // mark that we need a transform, so that any data that comes in\n              // will get processed, now that we've asked for it.\n              ts.needTransform = true;\n            }\n          };\n\n          Transform.prototype._destroy = function (err, cb) {\n            Duplex.prototype._destroy.call(this, err, function (err2) {\n              cb(err2);\n            });\n          };\n\n          function done(stream, er, data) {\n            if (er) return stream.emit('error', er);\n            if (data != null) // single equals check for both `null` and `undefined`\n              stream.push(data); // TODO(BridgeAR): Write a test for these two error cases\n            // if there's nothing in the write buffer, then that means\n            // that nothing more will ever be provided\n\n            if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();\n            if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();\n            return stream.push(null);\n          }\n          /***/\n\n        },\n\n        /***/\n        313:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_220399__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n          // A bit simpler than readable streams.\n          // Implement an async ._write(chunk, encoding, cb), and it'll handle all\n          // the drain event emission and buffering.\n\n          module.exports = Writable;\n          /* <replacement> */\n\n          function WriteReq(chunk, encoding, cb) {\n            this.chunk = chunk;\n            this.encoding = encoding;\n            this.callback = cb;\n            this.next = null;\n          } // It seems a linked list but it is not\n          // there will be only 2 of these for each stream\n\n\n          function CorkedRequest(state) {\n            var _this = this;\n\n            this.next = null;\n            this.entry = null;\n\n            this.finish = function () {\n              onCorkedFinish(_this, state);\n            };\n          }\n          /* </replacement> */\n\n          /*<replacement>*/\n\n\n          var Duplex;\n          /*</replacement>*/\n\n          Writable.WritableState = WritableState;\n          /*<replacement>*/\n\n          var internalUtil = {\n            deprecate: __nested_webpack_require_220399__(927)\n          };\n          /*</replacement>*/\n\n          /*<replacement>*/\n\n          var Stream = __nested_webpack_require_220399__(463);\n          /*</replacement>*/\n\n\n          var Buffer = __nested_webpack_require_220399__(764).Buffer;\n\n          var OurUint8Array = __nested_webpack_require_220399__.g.Uint8Array || function () {};\n\n          function _uint8ArrayToBuffer(chunk) {\n            return Buffer.from(chunk);\n          }\n\n          function _isUint8Array(obj) {\n            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n          }\n\n          var destroyImpl = __nested_webpack_require_220399__(369);\n\n          var _require = __nested_webpack_require_220399__(624),\n              getHighWaterMark = _require.getHighWaterMark;\n\n          var _require$codes = __nested_webpack_require_220399__(303)\n          /* .codes */\n          .q,\n              ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,\n              ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,\n              ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,\n              ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,\n              ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,\n              ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,\n              ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,\n              ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;\n\n          var errorOrDestroy = destroyImpl.errorOrDestroy;\n\n          __nested_webpack_require_220399__(717)(Writable, Stream);\n\n          function nop() {}\n\n          function WritableState(options, stream, isDuplex) {\n            Duplex = Duplex || __nested_webpack_require_220399__(560);\n            options = options || {}; // Duplex streams are both readable and writable, but share\n            // the same options object.\n            // However, some cases require setting options to different\n            // values for the readable and the writable sides of the duplex stream,\n            // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.\n\n            if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream\n            // contains buffers or objects.\n\n            this.objectMode = !!options.objectMode;\n            if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false\n            // Note: 0 is a valid value, means that we always return false if\n            // the entire buffer is not flushed immediately on write()\n\n            this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called\n\n            this.finalCalled = false; // drain event flag.\n\n            this.needDrain = false; // at the start of calling end()\n\n            this.ending = false; // when end() has been called, and returned\n\n            this.ended = false; // when 'finish' is emitted\n\n            this.finished = false; // has it been destroyed\n\n            this.destroyed = false; // should we decode strings into buffers before passing to _write?\n            // this is here so that some node-core streams can optimize string\n            // handling at a lower level.\n\n            var noDecode = options.decodeStrings === false;\n            this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string\n            // encoding is 'binary' so we have to make this configurable.\n            // Everything else in the universe uses 'utf8', though.\n\n            this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement\n            // of how much we're waiting to get pushed to some underlying\n            // socket or file.\n\n            this.length = 0; // a flag to see when we're in the middle of a write.\n\n            this.writing = false; // when true all writes will be buffered until .uncork() call\n\n            this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,\n            // or on a later tick.  We set this to true at first, because any\n            // actions that shouldn't happen until \"later\" should generally also\n            // not happen before the first write call.\n\n            this.sync = true; // a flag to know if we're processing previously buffered items, which\n            // may call the _write() callback in the same tick, so that we don't\n            // end up in an overlapped onwrite situation.\n\n            this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)\n\n            this.onwrite = function (er) {\n              onwrite(stream, er);\n            }; // the callback that the user supplies to write(chunk,encoding,cb)\n\n\n            this.writecb = null; // the amount that is being written when _write is called.\n\n            this.writelen = 0;\n            this.bufferedRequest = null;\n            this.lastBufferedRequest = null; // number of pending user-supplied write callbacks\n            // this must be 0 before 'finish' can be emitted\n\n            this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs\n            // This is relevant for synchronous Transform streams\n\n            this.prefinished = false; // True if the error was already emitted and should not be thrown again\n\n            this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.\n\n            this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')\n\n            this.autoDestroy = !!options.autoDestroy; // count buffered requests\n\n            this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always\n            // one allocated and free to use, and we maintain at most two\n\n            this.corkedRequestsFree = new CorkedRequest(this);\n          }\n\n          WritableState.prototype.getBuffer = function getBuffer() {\n            var current = this.bufferedRequest;\n            var out = [];\n\n            while (current) {\n              out.push(current);\n              current = current.next;\n            }\n\n            return out;\n          };\n\n          (function () {\n            try {\n              Object.defineProperty(WritableState.prototype, 'buffer', {\n                get: internalUtil.deprecate(function writableStateBufferGetter() {\n                  return this.getBuffer();\n                }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n              });\n            } catch (_) {}\n          })(); // Test _writableState for inheritance to account for Duplex streams,\n          // whose prototype chain only points to Readable.\n\n\n          var realHasInstance;\n\n          if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n            realHasInstance = Function.prototype[Symbol.hasInstance];\n            Object.defineProperty(Writable, Symbol.hasInstance, {\n              value: function value(object) {\n                if (realHasInstance.call(this, object)) return true;\n                if (this !== Writable) return false;\n                return object && object._writableState instanceof WritableState;\n              }\n            });\n          } else {\n            realHasInstance = function realHasInstance(object) {\n              return object instanceof this;\n            };\n          }\n\n          function Writable(options) {\n            Duplex = Duplex || __nested_webpack_require_220399__(560); // Writable ctor is applied to Duplexes, too.\n            // `realHasInstance` is necessary because using plain `instanceof`\n            // would return false, as no `_writableState` property is attached.\n            // Trying to use the custom `instanceof` for Writable here will also break the\n            // Node.js LazyTransform implementation, which has a non-trivial getter for\n            // `_writableState` that would lead to infinite recursion.\n            // Checking for a Stream.Duplex instance is faster here instead of inside\n            // the WritableState constructor, at least with V8 6.5\n\n            var isDuplex = this instanceof Duplex;\n            if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);\n            this._writableState = new WritableState(options, this, isDuplex); // legacy.\n\n            this.writable = true;\n\n            if (options) {\n              if (typeof options.write === 'function') this._write = options.write;\n              if (typeof options.writev === 'function') this._writev = options.writev;\n              if (typeof options.destroy === 'function') this._destroy = options.destroy;\n              if (typeof options.final === 'function') this._final = options.final;\n            }\n\n            Stream.call(this);\n          } // Otherwise people can pipe Writable streams, which is just wrong.\n\n\n          Writable.prototype.pipe = function () {\n            errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());\n          };\n\n          function writeAfterEnd(stream, cb) {\n            var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb\n\n            errorOrDestroy(stream, er);\n            process.nextTick(cb, er);\n          } // Checks that a user-supplied chunk is valid, especially for the particular\n          // mode the stream is in. Currently this means that `null` is never accepted\n          // and undefined/non-string values are only allowed in object mode.\n\n\n          function validChunk(stream, state, chunk, cb) {\n            var er;\n\n            if (chunk === null) {\n              er = new ERR_STREAM_NULL_VALUES();\n            } else if (typeof chunk !== 'string' && !state.objectMode) {\n              er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);\n            }\n\n            if (er) {\n              errorOrDestroy(stream, er);\n              process.nextTick(cb, er);\n              return false;\n            }\n\n            return true;\n          }\n\n          Writable.prototype.write = function (chunk, encoding, cb) {\n            var state = this._writableState;\n            var ret = false;\n\n            var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n            if (isBuf && !Buffer.isBuffer(chunk)) {\n              chunk = _uint8ArrayToBuffer(chunk);\n            }\n\n            if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n            if (typeof cb !== 'function') cb = nop;\n            if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n              state.pendingcb++;\n              ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n            }\n            return ret;\n          };\n\n          Writable.prototype.cork = function () {\n            this._writableState.corked++;\n          };\n\n          Writable.prototype.uncork = function () {\n            var state = this._writableState;\n\n            if (state.corked) {\n              state.corked--;\n              if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n            }\n          };\n\n          Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n            // node::ParseEncoding() requires lower case.\n            if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n            if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);\n            this._writableState.defaultEncoding = encoding;\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableBuffer', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState && this._writableState.getBuffer();\n            }\n          });\n\n          function decodeChunk(state, chunk, encoding) {\n            if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n              chunk = Buffer.from(chunk, encoding);\n            }\n\n            return chunk;\n          }\n\n          Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.highWaterMark;\n            }\n          }); // if we're already writing something, then just put this\n          // in the queue, and wait our turn.  Otherwise, call _write\n          // If we return false, then we need a drain event, so set that flag.\n\n          function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n            if (!isBuf) {\n              var newChunk = decodeChunk(state, chunk, encoding);\n\n              if (chunk !== newChunk) {\n                isBuf = true;\n                encoding = 'buffer';\n                chunk = newChunk;\n              }\n            }\n\n            var len = state.objectMode ? 1 : chunk.length;\n            state.length += len;\n            var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.\n\n            if (!ret) state.needDrain = true;\n\n            if (state.writing || state.corked) {\n              var last = state.lastBufferedRequest;\n              state.lastBufferedRequest = {\n                chunk: chunk,\n                encoding: encoding,\n                isBuf: isBuf,\n                callback: cb,\n                next: null\n              };\n\n              if (last) {\n                last.next = state.lastBufferedRequest;\n              } else {\n                state.bufferedRequest = state.lastBufferedRequest;\n              }\n\n              state.bufferedRequestCount += 1;\n            } else {\n              doWrite(stream, state, false, len, chunk, encoding, cb);\n            }\n\n            return ret;\n          }\n\n          function doWrite(stream, state, writev, len, chunk, encoding, cb) {\n            state.writelen = len;\n            state.writecb = cb;\n            state.writing = true;\n            state.sync = true;\n            if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n            state.sync = false;\n          }\n\n          function onwriteError(stream, state, sync, er, cb) {\n            --state.pendingcb;\n\n            if (sync) {\n              // defer the callback if we are being called synchronously\n              // to avoid piling up things on the stack\n              process.nextTick(cb, er); // this can emit finish, and it will always happen\n              // after error\n\n              process.nextTick(finishMaybe, stream, state);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er);\n            } else {\n              // the caller expect this to happen before if\n              // it is async\n              cb(er);\n              stream._writableState.errorEmitted = true;\n              errorOrDestroy(stream, er); // this can emit finish, but finish must\n              // always follow error\n\n              finishMaybe(stream, state);\n            }\n          }\n\n          function onwriteStateUpdate(state) {\n            state.writing = false;\n            state.writecb = null;\n            state.length -= state.writelen;\n            state.writelen = 0;\n          }\n\n          function onwrite(stream, er) {\n            var state = stream._writableState;\n            var sync = state.sync;\n            var cb = state.writecb;\n            if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();\n            onwriteStateUpdate(state);\n            if (er) onwriteError(stream, state, sync, er, cb);else {\n              // Check if we're actually ready to finish, but don't emit yet\n              var finished = needFinish(state) || stream.destroyed;\n\n              if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n                clearBuffer(stream, state);\n              }\n\n              if (sync) {\n                process.nextTick(afterWrite, stream, state, finished, cb);\n              } else {\n                afterWrite(stream, state, finished, cb);\n              }\n            }\n          }\n\n          function afterWrite(stream, state, finished, cb) {\n            if (!finished) onwriteDrain(stream, state);\n            state.pendingcb--;\n            cb();\n            finishMaybe(stream, state);\n          } // Must force callback to be called on nextTick, so that we don't\n          // emit 'drain' before the write() consumer gets the 'false' return\n          // value, and has a chance to attach a 'drain' listener.\n\n\n          function onwriteDrain(stream, state) {\n            if (state.length === 0 && state.needDrain) {\n              state.needDrain = false;\n              stream.emit('drain');\n            }\n          } // if there's something in the buffer waiting, then process it\n\n\n          function clearBuffer(stream, state) {\n            state.bufferProcessing = true;\n            var entry = state.bufferedRequest;\n\n            if (stream._writev && entry && entry.next) {\n              // Fast case, write everything using _writev()\n              var l = state.bufferedRequestCount;\n              var buffer = new Array(l);\n              var holder = state.corkedRequestsFree;\n              holder.entry = entry;\n              var count = 0;\n              var allBuffers = true;\n\n              while (entry) {\n                buffer[count] = entry;\n                if (!entry.isBuf) allBuffers = false;\n                entry = entry.next;\n                count += 1;\n              }\n\n              buffer.allBuffers = allBuffers;\n              doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time\n              // as the hot path ends with doWrite\n\n              state.pendingcb++;\n              state.lastBufferedRequest = null;\n\n              if (holder.next) {\n                state.corkedRequestsFree = holder.next;\n                holder.next = null;\n              } else {\n                state.corkedRequestsFree = new CorkedRequest(state);\n              }\n\n              state.bufferedRequestCount = 0;\n            } else {\n              // Slow case, write chunks one-by-one\n              while (entry) {\n                var chunk = entry.chunk;\n                var encoding = entry.encoding;\n                var cb = entry.callback;\n                var len = state.objectMode ? 1 : chunk.length;\n                doWrite(stream, state, false, len, chunk, encoding, cb);\n                entry = entry.next;\n                state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then\n                // it means that we need to wait until it does.\n                // also, that means that the chunk and cb are currently\n                // being processed, so move the buffer counter past them.\n\n                if (state.writing) {\n                  break;\n                }\n              }\n\n              if (entry === null) state.lastBufferedRequest = null;\n            }\n\n            state.bufferedRequest = entry;\n            state.bufferProcessing = false;\n          }\n\n          Writable.prototype._write = function (chunk, encoding, cb) {\n            cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));\n          };\n\n          Writable.prototype._writev = null;\n\n          Writable.prototype.end = function (chunk, encoding, cb) {\n            var state = this._writableState;\n\n            if (typeof chunk === 'function') {\n              cb = chunk;\n              chunk = null;\n              encoding = null;\n            } else if (typeof encoding === 'function') {\n              cb = encoding;\n              encoding = null;\n            }\n\n            if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks\n\n            if (state.corked) {\n              state.corked = 1;\n              this.uncork();\n            } // ignore unnecessary end() calls.\n\n\n            if (!state.ending) endWritable(this, state, cb);\n            return this;\n          };\n\n          Object.defineProperty(Writable.prototype, 'writableLength', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              return this._writableState.length;\n            }\n          });\n\n          function needFinish(state) {\n            return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n          }\n\n          function callFinal(stream, state) {\n            stream._final(function (err) {\n              state.pendingcb--;\n\n              if (err) {\n                errorOrDestroy(stream, err);\n              }\n\n              state.prefinished = true;\n              stream.emit('prefinish');\n              finishMaybe(stream, state);\n            });\n          }\n\n          function prefinish(stream, state) {\n            if (!state.prefinished && !state.finalCalled) {\n              if (typeof stream._final === 'function' && !state.destroyed) {\n                state.pendingcb++;\n                state.finalCalled = true;\n                process.nextTick(callFinal, stream, state);\n              } else {\n                state.prefinished = true;\n                stream.emit('prefinish');\n              }\n            }\n          }\n\n          function finishMaybe(stream, state) {\n            var need = needFinish(state);\n\n            if (need) {\n              prefinish(stream, state);\n\n              if (state.pendingcb === 0) {\n                state.finished = true;\n                stream.emit('finish');\n\n                if (state.autoDestroy) {\n                  // In case of duplex streams we need a way to detect\n                  // if the readable side is ready for autoDestroy as well\n                  var rState = stream._readableState;\n\n                  if (!rState || rState.autoDestroy && rState.endEmitted) {\n                    stream.destroy();\n                  }\n                }\n              }\n            }\n\n            return need;\n          }\n\n          function endWritable(stream, state, cb) {\n            state.ending = true;\n            finishMaybe(stream, state);\n\n            if (cb) {\n              if (state.finished) process.nextTick(cb);else stream.once('finish', cb);\n            }\n\n            state.ended = true;\n            stream.writable = false;\n          }\n\n          function onCorkedFinish(corkReq, state, err) {\n            var entry = corkReq.entry;\n            corkReq.entry = null;\n\n            while (entry) {\n              var cb = entry.callback;\n              state.pendingcb--;\n              cb(err);\n              entry = entry.next;\n            } // reuse the free corkReq.\n\n\n            state.corkedRequestsFree.next = corkReq;\n          }\n\n          Object.defineProperty(Writable.prototype, 'destroyed', {\n            // making it explicit this property is not enumerable\n            // because otherwise some prototype manipulation in\n            // userland will fail\n            enumerable: false,\n            get: function get() {\n              if (this._writableState === undefined) {\n                return false;\n              }\n\n              return this._writableState.destroyed;\n            },\n            set: function set(value) {\n              // we ignore the value if the stream\n              // has not been initialized yet\n              if (!this._writableState) {\n                return;\n              } // backward compatibility, the user is explicitly\n              // managing destroyed\n\n\n              this._writableState.destroyed = value;\n            }\n          });\n          Writable.prototype.destroy = destroyImpl.destroy;\n          Writable.prototype._undestroy = destroyImpl.undestroy;\n\n          Writable.prototype._destroy = function (err, cb) {\n            cb(err);\n          };\n          /***/\n\n        },\n\n        /***/\n        819:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_247848__) => {\n          \"use strict\";\n\n          var _Object$setPrototypeO;\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          var finished = __nested_webpack_require_247848__(467);\n\n          var kLastResolve = Symbol('lastResolve');\n          var kLastReject = Symbol('lastReject');\n          var kError = Symbol('error');\n          var kEnded = Symbol('ended');\n          var kLastPromise = Symbol('lastPromise');\n          var kHandlePromise = Symbol('handlePromise');\n          var kStream = Symbol('stream');\n\n          function createIterResult(value, done) {\n            return {\n              value: value,\n              done: done\n            };\n          }\n\n          function readAndResolve(iter) {\n            var resolve = iter[kLastResolve];\n\n            if (resolve !== null) {\n              var data = iter[kStream].read(); // we defer if data is null\n              // we can be expecting either 'end' or\n              // 'error'\n\n              if (data !== null) {\n                iter[kLastPromise] = null;\n                iter[kLastResolve] = null;\n                iter[kLastReject] = null;\n                resolve(createIterResult(data, false));\n              }\n            }\n          }\n\n          function onReadable(iter) {\n            // we wait for the next tick, because it might\n            // emit an error with process.nextTick\n            process.nextTick(readAndResolve, iter);\n          }\n\n          function wrapForNext(lastPromise, iter) {\n            return function (resolve, reject) {\n              lastPromise.then(function () {\n                if (iter[kEnded]) {\n                  resolve(createIterResult(undefined, true));\n                  return;\n                }\n\n                iter[kHandlePromise](resolve, reject);\n              }, reject);\n            };\n          }\n\n          var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});\n          var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {\n            get stream() {\n              return this[kStream];\n            },\n\n            next: function next() {\n              var _this = this; // if we have detected an error in the meanwhile\n              // reject straight away\n\n\n              var error = this[kError];\n\n              if (error !== null) {\n                return Promise.reject(error);\n              }\n\n              if (this[kEnded]) {\n                return Promise.resolve(createIterResult(undefined, true));\n              }\n\n              if (this[kStream].destroyed) {\n                // We need to defer via nextTick because if .destroy(err) is\n                // called, the error will be emitted via nextTick, and\n                // we cannot guarantee that there is no error lingering around\n                // waiting to be emitted.\n                return new Promise(function (resolve, reject) {\n                  process.nextTick(function () {\n                    if (_this[kError]) {\n                      reject(_this[kError]);\n                    } else {\n                      resolve(createIterResult(undefined, true));\n                    }\n                  });\n                });\n              } // if we have multiple next() calls\n              // we will wait for the previous Promise to finish\n              // this logic is optimized to support for await loops,\n              // where next() is only called once at a time\n\n\n              var lastPromise = this[kLastPromise];\n              var promise;\n\n              if (lastPromise) {\n                promise = new Promise(wrapForNext(lastPromise, this));\n              } else {\n                // fast path needed to support multiple this.push()\n                // without triggering the next() queue\n                var data = this[kStream].read();\n\n                if (data !== null) {\n                  return Promise.resolve(createIterResult(data, false));\n                }\n\n                promise = new Promise(this[kHandlePromise]);\n              }\n\n              this[kLastPromise] = promise;\n              return promise;\n            }\n          }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {\n            return this;\n          }), _defineProperty(_Object$setPrototypeO, \"return\", function _return() {\n            var _this2 = this; // destroy(err, cb) is a private API\n            // we can guarantee we have that here, because we control the\n            // Readable class this is attached to\n\n\n            return new Promise(function (resolve, reject) {\n              _this2[kStream].destroy(null, function (err) {\n                if (err) {\n                  reject(err);\n                  return;\n                }\n\n                resolve(createIterResult(undefined, true));\n              });\n            });\n          }), _Object$setPrototypeO), AsyncIteratorPrototype);\n\n          var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {\n            var _Object$create;\n\n            var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {\n              value: stream,\n              writable: true\n            }), _defineProperty(_Object$create, kLastResolve, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kLastReject, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kError, {\n              value: null,\n              writable: true\n            }), _defineProperty(_Object$create, kEnded, {\n              value: stream._readableState.endEmitted,\n              writable: true\n            }), _defineProperty(_Object$create, kHandlePromise, {\n              value: function value(resolve, reject) {\n                var data = iterator[kStream].read();\n\n                if (data) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  resolve(createIterResult(data, false));\n                } else {\n                  iterator[kLastResolve] = resolve;\n                  iterator[kLastReject] = reject;\n                }\n              },\n              writable: true\n            }), _Object$create));\n            iterator[kLastPromise] = null;\n            finished(stream, function (err) {\n              if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n                var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise\n                // returned by next() and store the error\n\n                if (reject !== null) {\n                  iterator[kLastPromise] = null;\n                  iterator[kLastResolve] = null;\n                  iterator[kLastReject] = null;\n                  reject(err);\n                }\n\n                iterator[kError] = err;\n                return;\n              }\n\n              var resolve = iterator[kLastResolve];\n\n              if (resolve !== null) {\n                iterator[kLastPromise] = null;\n                iterator[kLastResolve] = null;\n                iterator[kLastReject] = null;\n                resolve(createIterResult(undefined, true));\n              }\n\n              iterator[kEnded] = true;\n            });\n            stream.on('readable', onReadable.bind(null, iterator));\n            return iterator;\n          };\n\n          module.exports = createReadableStreamAsyncIterator;\n          /***/\n        },\n\n        /***/\n        641:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_255813__) => {\n          \"use strict\";\n\n          function ownKeys(object, enumerableOnly) {\n            var keys = Object.keys(object);\n\n            if (Object.getOwnPropertySymbols) {\n              var symbols = Object.getOwnPropertySymbols(object);\n              if (enumerableOnly) symbols = symbols.filter(function (sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n              });\n              keys.push.apply(keys, symbols);\n            }\n\n            return keys;\n          }\n\n          function _objectSpread(target) {\n            for (var i = 1; i < arguments.length; i++) {\n              var source = arguments[i] != null ? arguments[i] : {};\n\n              if (i % 2) {\n                ownKeys(Object(source), true).forEach(function (key) {\n                  _defineProperty(target, key, source[key]);\n                });\n              } else if (Object.getOwnPropertyDescriptors) {\n                Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n              } else {\n                ownKeys(Object(source)).forEach(function (key) {\n                  Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n                });\n              }\n            }\n\n            return target;\n          }\n\n          function _defineProperty(obj, key, value) {\n            if (key in obj) {\n              Object.defineProperty(obj, key, {\n                value: value,\n                enumerable: true,\n                configurable: true,\n                writable: true\n              });\n            } else {\n              obj[key] = value;\n            }\n\n            return obj;\n          }\n\n          function _classCallCheck(instance, Constructor) {\n            if (!(instance instanceof Constructor)) {\n              throw new TypeError(\"Cannot call a class as a function\");\n            }\n          }\n\n          function _defineProperties(target, props) {\n            for (var i = 0; i < props.length; i++) {\n              var descriptor = props[i];\n              descriptor.enumerable = descriptor.enumerable || false;\n              descriptor.configurable = true;\n              if (\"value\" in descriptor) descriptor.writable = true;\n              Object.defineProperty(target, descriptor.key, descriptor);\n            }\n          }\n\n          function _createClass(Constructor, protoProps, staticProps) {\n            if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n            if (staticProps) _defineProperties(Constructor, staticProps);\n            return Constructor;\n          }\n\n          var _require = __nested_webpack_require_255813__(764),\n              Buffer = _require.Buffer;\n\n          var _require2 = __nested_webpack_require_255813__(758),\n              inspect = _require2.inspect;\n\n          var custom = inspect && inspect.custom || 'inspect';\n\n          function copyBuffer(src, target, offset) {\n            Buffer.prototype.copy.call(src, target, offset);\n          }\n\n          module.exports = /*#__PURE__*/function () {\n            function BufferList() {\n              _classCallCheck(this, BufferList);\n\n              this.head = null;\n              this.tail = null;\n              this.length = 0;\n            }\n\n            _createClass(BufferList, [{\n              key: \"push\",\n              value: function push(v) {\n                var entry = {\n                  data: v,\n                  next: null\n                };\n                if (this.length > 0) this.tail.next = entry;else this.head = entry;\n                this.tail = entry;\n                ++this.length;\n              }\n            }, {\n              key: \"unshift\",\n              value: function unshift(v) {\n                var entry = {\n                  data: v,\n                  next: this.head\n                };\n                if (this.length === 0) this.tail = entry;\n                this.head = entry;\n                ++this.length;\n              }\n            }, {\n              key: \"shift\",\n              value: function shift() {\n                if (this.length === 0) return;\n                var ret = this.head.data;\n                if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n                --this.length;\n                return ret;\n              }\n            }, {\n              key: \"clear\",\n              value: function clear() {\n                this.head = this.tail = null;\n                this.length = 0;\n              }\n            }, {\n              key: \"join\",\n              value: function join(s) {\n                if (this.length === 0) return '';\n                var p = this.head;\n                var ret = '' + p.data;\n\n                while (p = p.next) {\n                  ret += s + p.data;\n                }\n\n                return ret;\n              }\n            }, {\n              key: \"concat\",\n              value: function concat(n) {\n                if (this.length === 0) return Buffer.alloc(0);\n                var ret = Buffer.allocUnsafe(n >>> 0);\n                var p = this.head;\n                var i = 0;\n\n                while (p) {\n                  copyBuffer(p.data, ret, i);\n                  i += p.data.length;\n                  p = p.next;\n                }\n\n                return ret;\n              } // Consumes a specified amount of bytes or characters from the buffered data.\n\n            }, {\n              key: \"consume\",\n              value: function consume(n, hasStrings) {\n                var ret;\n\n                if (n < this.head.data.length) {\n                  // `slice` is the same for buffers and strings.\n                  ret = this.head.data.slice(0, n);\n                  this.head.data = this.head.data.slice(n);\n                } else if (n === this.head.data.length) {\n                  // First chunk is a perfect match.\n                  ret = this.shift();\n                } else {\n                  // Result spans more than one buffer.\n                  ret = hasStrings ? this._getString(n) : this._getBuffer(n);\n                }\n\n                return ret;\n              }\n            }, {\n              key: \"first\",\n              value: function first() {\n                return this.head.data;\n              } // Consumes a specified amount of characters from the buffered data.\n\n            }, {\n              key: \"_getString\",\n              value: function _getString(n) {\n                var p = this.head;\n                var c = 1;\n                var ret = p.data;\n                n -= ret.length;\n\n                while (p = p.next) {\n                  var str = p.data;\n                  var nb = n > str.length ? str.length : n;\n                  if (nb === str.length) ret += str;else ret += str.slice(0, n);\n                  n -= nb;\n\n                  if (n === 0) {\n                    if (nb === str.length) {\n                      ++c;\n                      if (p.next) this.head = p.next;else this.head = this.tail = null;\n                    } else {\n                      this.head = p;\n                      p.data = str.slice(nb);\n                    }\n\n                    break;\n                  }\n\n                  ++c;\n                }\n\n                this.length -= c;\n                return ret;\n              } // Consumes a specified amount of bytes from the buffered data.\n\n            }, {\n              key: \"_getBuffer\",\n              value: function _getBuffer(n) {\n                var ret = Buffer.allocUnsafe(n);\n                var p = this.head;\n                var c = 1;\n                p.data.copy(ret);\n                n -= p.data.length;\n\n                while (p = p.next) {\n                  var buf = p.data;\n                  var nb = n > buf.length ? buf.length : n;\n                  buf.copy(ret, ret.length - n, 0, nb);\n                  n -= nb;\n\n                  if (n === 0) {\n                    if (nb === buf.length) {\n                      ++c;\n                      if (p.next) this.head = p.next;else this.head = this.tail = null;\n                    } else {\n                      this.head = p;\n                      p.data = buf.slice(nb);\n                    }\n\n                    break;\n                  }\n\n                  ++c;\n                }\n\n                this.length -= c;\n                return ret;\n              } // Make sure the linked list only shows the minimal necessary information.\n\n            }, {\n              key: custom,\n              value: function value(_, options) {\n                return inspect(this, _objectSpread({}, options, {\n                  // Only inspect one level.\n                  depth: 0,\n                  // It should not recurse.\n                  customInspect: false\n                }));\n              }\n            }]);\n\n            return BufferList;\n          }();\n          /***/\n\n        },\n\n        /***/\n        369:\n        /***/\n        module => {\n          \"use strict\"; // undocumented cb() API, needed for core, not for public API\n\n          function destroy(err, cb) {\n            var _this = this;\n\n            var readableDestroyed = this._readableState && this._readableState.destroyed;\n            var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n            if (readableDestroyed || writableDestroyed) {\n              if (cb) {\n                cb(err);\n              } else if (err) {\n                if (!this._writableState) {\n                  process.nextTick(emitErrorNT, this, err);\n                } else if (!this._writableState.errorEmitted) {\n                  this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorNT, this, err);\n                }\n              }\n\n              return this;\n            } // we set destroyed to true before firing error callbacks in order\n            // to make it re-entrance safe in case destroy() is called within callbacks\n\n\n            if (this._readableState) {\n              this._readableState.destroyed = true;\n            } // if this is a duplex stream mark the writable part as destroyed as well\n\n\n            if (this._writableState) {\n              this._writableState.destroyed = true;\n            }\n\n            this._destroy(err || null, function (err) {\n              if (!cb && err) {\n                if (!_this._writableState) {\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else if (!_this._writableState.errorEmitted) {\n                  _this._writableState.errorEmitted = true;\n                  process.nextTick(emitErrorAndCloseNT, _this, err);\n                } else {\n                  process.nextTick(emitCloseNT, _this);\n                }\n              } else if (cb) {\n                process.nextTick(emitCloseNT, _this);\n                cb(err);\n              } else {\n                process.nextTick(emitCloseNT, _this);\n              }\n            });\n\n            return this;\n          }\n\n          function emitErrorAndCloseNT(self, err) {\n            emitErrorNT(self, err);\n            emitCloseNT(self);\n          }\n\n          function emitCloseNT(self) {\n            if (self._writableState && !self._writableState.emitClose) return;\n            if (self._readableState && !self._readableState.emitClose) return;\n            self.emit('close');\n          }\n\n          function undestroy() {\n            if (this._readableState) {\n              this._readableState.destroyed = false;\n              this._readableState.reading = false;\n              this._readableState.ended = false;\n              this._readableState.endEmitted = false;\n            }\n\n            if (this._writableState) {\n              this._writableState.destroyed = false;\n              this._writableState.ended = false;\n              this._writableState.ending = false;\n              this._writableState.finalCalled = false;\n              this._writableState.prefinished = false;\n              this._writableState.finished = false;\n              this._writableState.errorEmitted = false;\n            }\n          }\n\n          function emitErrorNT(self, err) {\n            self.emit('error', err);\n          }\n\n          function errorOrDestroy(stream, err) {\n            // We have tests that rely on errors being emitted\n            // in the same tick, so changing this is semver major.\n            // For now when you opt-in to autoDestroy we allow\n            // the error to be emitted nextTick. In a future\n            // semver major update we should change the default to this.\n            var rState = stream._readableState;\n            var wState = stream._writableState;\n            if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);\n          }\n\n          module.exports = {\n            destroy: destroy,\n            undestroy: undestroy,\n            errorOrDestroy: errorOrDestroy\n          };\n          /***/\n        },\n\n        /***/\n        467:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_268859__) => {\n          \"use strict\"; // Ported from https://github.com/mafintosh/end-of-stream with\n          // permission from the author, Mathias Buus (@mafintosh).\n\n          var ERR_STREAM_PREMATURE_CLOSE = __nested_webpack_require_268859__(303)\n          /* .codes.ERR_STREAM_PREMATURE_CLOSE */\n          .q.ERR_STREAM_PREMATURE_CLOSE;\n\n          function once(callback) {\n            var called = false;\n            return function () {\n              if (called) return;\n              called = true;\n\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n\n              callback.apply(this, args);\n            };\n          }\n\n          function noop() {}\n\n          function isRequest(stream) {\n            return stream.setHeader && typeof stream.abort === 'function';\n          }\n\n          function eos(stream, opts, callback) {\n            if (typeof opts === 'function') return eos(stream, null, opts);\n            if (!opts) opts = {};\n            callback = once(callback || noop);\n            var readable = opts.readable || opts.readable !== false && stream.readable;\n            var writable = opts.writable || opts.writable !== false && stream.writable;\n\n            var onlegacyfinish = function onlegacyfinish() {\n              if (!stream.writable) onfinish();\n            };\n\n            var writableEnded = stream._writableState && stream._writableState.finished;\n\n            var onfinish = function onfinish() {\n              writable = false;\n              writableEnded = true;\n              if (!readable) callback.call(stream);\n            };\n\n            var readableEnded = stream._readableState && stream._readableState.endEmitted;\n\n            var onend = function onend() {\n              readable = false;\n              readableEnded = true;\n              if (!writable) callback.call(stream);\n            };\n\n            var onerror = function onerror(err) {\n              callback.call(stream, err);\n            };\n\n            var onclose = function onclose() {\n              var err;\n\n              if (readable && !readableEnded) {\n                if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n                return callback.call(stream, err);\n              }\n\n              if (writable && !writableEnded) {\n                if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();\n                return callback.call(stream, err);\n              }\n            };\n\n            var onrequest = function onrequest() {\n              stream.req.on('finish', onfinish);\n            };\n\n            if (isRequest(stream)) {\n              stream.on('complete', onfinish);\n              stream.on('abort', onclose);\n              if (stream.req) onrequest();else stream.on('request', onrequest);\n            } else if (writable && !stream._writableState) {\n              // legacy streams\n              stream.on('end', onlegacyfinish);\n              stream.on('close', onlegacyfinish);\n            }\n\n            stream.on('end', onend);\n            stream.on('finish', onfinish);\n            if (opts.error !== false) stream.on('error', onerror);\n            stream.on('close', onclose);\n            return function () {\n              stream.removeListener('complete', onfinish);\n              stream.removeListener('abort', onclose);\n              stream.removeListener('request', onrequest);\n              if (stream.req) stream.req.removeListener('finish', onfinish);\n              stream.removeListener('end', onlegacyfinish);\n              stream.removeListener('close', onlegacyfinish);\n              stream.removeListener('finish', onfinish);\n              stream.removeListener('end', onend);\n              stream.removeListener('error', onerror);\n              stream.removeListener('close', onclose);\n            };\n          }\n\n          module.exports = eos;\n          /***/\n        },\n\n        /***/\n        869:\n        /***/\n        module => {\n          module.exports = function () {\n            throw new Error('Readable.from is not available in the browser');\n          };\n          /***/\n\n        },\n\n        /***/\n        689:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_273207__) => {\n          \"use strict\"; // Ported from https://github.com/mafintosh/pump with\n          // permission from the author, Mathias Buus (@mafintosh).\n\n          var eos;\n\n          function once(callback) {\n            var called = false;\n            return function () {\n              if (called) return;\n              called = true;\n              callback.apply(void 0, arguments);\n            };\n          }\n\n          var _require$codes = __nested_webpack_require_273207__(303)\n          /* .codes */\n          .q,\n              ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,\n              ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;\n\n          function noop(err) {\n            // Rethrow the error if it exists to avoid swallowing it\n            if (err) throw err;\n          }\n\n          function isRequest(stream) {\n            return stream.setHeader && typeof stream.abort === 'function';\n          }\n\n          function destroyer(stream, reading, writing, callback) {\n            callback = once(callback);\n            var closed = false;\n            stream.on('close', function () {\n              closed = true;\n            });\n            if (eos === undefined) eos = __nested_webpack_require_273207__(467);\n            eos(stream, {\n              readable: reading,\n              writable: writing\n            }, function (err) {\n              if (err) return callback(err);\n              closed = true;\n              callback();\n            });\n            var destroyed = false;\n            return function (err) {\n              if (closed) return;\n              if (destroyed) return;\n              destroyed = true; // request.destroy just do .end - .abort is what we want\n\n              if (isRequest(stream)) return stream.abort();\n              if (typeof stream.destroy === 'function') return stream.destroy();\n              callback(err || new ERR_STREAM_DESTROYED('pipe'));\n            };\n          }\n\n          function call(fn) {\n            fn();\n          }\n\n          function pipe(from, to) {\n            return from.pipe(to);\n          }\n\n          function popCallback(streams) {\n            if (!streams.length) return noop;\n            if (typeof streams[streams.length - 1] !== 'function') return noop;\n            return streams.pop();\n          }\n\n          function pipeline() {\n            for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n              streams[_key] = arguments[_key];\n            }\n\n            var callback = popCallback(streams);\n            if (Array.isArray(streams[0])) streams = streams[0];\n\n            if (streams.length < 2) {\n              throw new ERR_MISSING_ARGS('streams');\n            }\n\n            var error;\n            var destroys = streams.map(function (stream, i) {\n              var reading = i < streams.length - 1;\n              var writing = i > 0;\n              return destroyer(stream, reading, writing, function (err) {\n                if (!error) error = err;\n                if (err) destroys.forEach(call);\n                if (reading) return;\n                destroys.forEach(call);\n                callback(error);\n              });\n            });\n            return streams.reduce(pipe);\n          }\n\n          module.exports = pipeline;\n          /***/\n        },\n\n        /***/\n        624:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_276610__) => {\n          \"use strict\";\n\n          var ERR_INVALID_OPT_VALUE = __nested_webpack_require_276610__(303)\n          /* .codes.ERR_INVALID_OPT_VALUE */\n          .q.ERR_INVALID_OPT_VALUE;\n\n          function highWaterMarkFrom(options, isDuplex, duplexKey) {\n            return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;\n          }\n\n          function getHighWaterMark(state, options, duplexKey, isDuplex) {\n            var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);\n\n            if (hwm != null) {\n              if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {\n                var name = isDuplex ? duplexKey : 'highWaterMark';\n                throw new ERR_INVALID_OPT_VALUE(name, hwm);\n              }\n\n              return Math.floor(hwm);\n            } // Default value\n\n\n            return state.objectMode ? 16 : 16 * 1024;\n          }\n\n          module.exports = {\n            getHighWaterMark: getHighWaterMark\n          };\n          /***/\n        },\n\n        /***/\n        463:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_277738__) => {\n          module.exports = __nested_webpack_require_277738__(187).EventEmitter;\n          /***/\n        },\n\n        /***/\n        925:\n        /***/\n        (module, exports, __nested_webpack_require_277925__) => {\n          exports = module.exports = __nested_webpack_require_277925__(2);\n          exports.Stream = exports;\n          exports.Readable = exports;\n          exports.Writable = __nested_webpack_require_277925__(313);\n          exports.Duplex = __nested_webpack_require_277925__(560);\n          exports.Transform = __nested_webpack_require_277925__(846);\n          exports.PassThrough = __nested_webpack_require_277925__(842);\n          exports.finished = __nested_webpack_require_277925__(467);\n          exports.pipeline = __nested_webpack_require_277925__(689);\n          /***/\n        },\n\n        /***/\n        553:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_278530__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n          /*<replacement>*/\n\n          var Buffer = __nested_webpack_require_278530__(509).Buffer;\n          /*</replacement>*/\n\n\n          var isEncoding = Buffer.isEncoding || function (encoding) {\n            encoding = '' + encoding;\n\n            switch (encoding && encoding.toLowerCase()) {\n              case 'hex':\n              case 'utf8':\n              case 'utf-8':\n              case 'ascii':\n              case 'binary':\n              case 'base64':\n              case 'ucs2':\n              case 'ucs-2':\n              case 'utf16le':\n              case 'utf-16le':\n              case 'raw':\n                return true;\n\n              default:\n                return false;\n            }\n          };\n\n          function _normalizeEncoding(enc) {\n            if (!enc) return 'utf8';\n            var retried;\n\n            while (true) {\n              switch (enc) {\n                case 'utf8':\n                case 'utf-8':\n                  return 'utf8';\n\n                case 'ucs2':\n                case 'ucs-2':\n                case 'utf16le':\n                case 'utf-16le':\n                  return 'utf16le';\n\n                case 'latin1':\n                case 'binary':\n                  return 'latin1';\n\n                case 'base64':\n                case 'ascii':\n                case 'hex':\n                  return enc;\n\n                default:\n                  if (retried) return; // undefined\n\n                  enc = ('' + enc).toLowerCase();\n                  retried = true;\n              }\n            }\n          }\n\n          ; // Do not cache `Buffer.isEncoding` when checking encoding names as some\n          // modules monkey-patch it to support additional encodings\n\n          function normalizeEncoding(enc) {\n            var nenc = _normalizeEncoding(enc);\n\n            if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n            return nenc || enc;\n          } // StringDecoder provides an interface for efficiently splitting a series of\n          // buffers into a series of JS strings without breaking apart multi-byte\n          // characters.\n\n\n          exports.s = StringDecoder;\n\n          function StringDecoder(encoding) {\n            this.encoding = normalizeEncoding(encoding);\n            var nb;\n\n            switch (this.encoding) {\n              case 'utf16le':\n                this.text = utf16Text;\n                this.end = utf16End;\n                nb = 4;\n                break;\n\n              case 'utf8':\n                this.fillLast = utf8FillLast;\n                nb = 4;\n                break;\n\n              case 'base64':\n                this.text = base64Text;\n                this.end = base64End;\n                nb = 3;\n                break;\n\n              default:\n                this.write = simpleWrite;\n                this.end = simpleEnd;\n                return;\n            }\n\n            this.lastNeed = 0;\n            this.lastTotal = 0;\n            this.lastChar = Buffer.allocUnsafe(nb);\n          }\n\n          StringDecoder.prototype.write = function (buf) {\n            if (buf.length === 0) return '';\n            var r;\n            var i;\n\n            if (this.lastNeed) {\n              r = this.fillLast(buf);\n              if (r === undefined) return '';\n              i = this.lastNeed;\n              this.lastNeed = 0;\n            } else {\n              i = 0;\n            }\n\n            if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n            return r || '';\n          };\n\n          StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer\n\n          StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\n\n          StringDecoder.prototype.fillLast = function (buf) {\n            if (this.lastNeed <= buf.length) {\n              buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n              return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n            }\n\n            buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n            this.lastNeed -= buf.length;\n          }; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n          // continuation byte. If an invalid byte is detected, -2 is returned.\n\n\n          function utf8CheckByte(byte) {\n            if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n            return byte >> 6 === 0x02 ? -1 : -2;\n          } // Checks at most 3 bytes at the end of a Buffer in order to detect an\n          // incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n          // needed to complete the UTF-8 character (if applicable) are returned.\n\n\n          function utf8CheckIncomplete(self, buf, i) {\n            var j = buf.length - 1;\n            if (j < i) return 0;\n            var nb = utf8CheckByte(buf[j]);\n\n            if (nb >= 0) {\n              if (nb > 0) self.lastNeed = nb - 1;\n              return nb;\n            }\n\n            if (--j < i || nb === -2) return 0;\n            nb = utf8CheckByte(buf[j]);\n\n            if (nb >= 0) {\n              if (nb > 0) self.lastNeed = nb - 2;\n              return nb;\n            }\n\n            if (--j < i || nb === -2) return 0;\n            nb = utf8CheckByte(buf[j]);\n\n            if (nb >= 0) {\n              if (nb > 0) {\n                if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n              }\n\n              return nb;\n            }\n\n            return 0;\n          } // Validates as many continuation bytes for a multi-byte UTF-8 character as\n          // needed or are available. If we see a non-continuation byte where we expect\n          // one, we \"replace\" the validated continuation bytes we've seen so far with\n          // a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n          // behavior. The continuation byte check is included three times in the case\n          // where all of the continuation bytes for a character exist in the same buffer.\n          // It is also done this way as a slight performance increase instead of using a\n          // loop.\n\n\n          function utf8CheckExtraBytes(self, buf, p) {\n            if ((buf[0] & 0xC0) !== 0x80) {\n              self.lastNeed = 0;\n              return '\\ufffd';\n            }\n\n            if (self.lastNeed > 1 && buf.length > 1) {\n              if ((buf[1] & 0xC0) !== 0x80) {\n                self.lastNeed = 1;\n                return '\\ufffd';\n              }\n\n              if (self.lastNeed > 2 && buf.length > 2) {\n                if ((buf[2] & 0xC0) !== 0x80) {\n                  self.lastNeed = 2;\n                  return '\\ufffd';\n                }\n              }\n            }\n          } // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\n\n\n          function utf8FillLast(buf) {\n            var p = this.lastTotal - this.lastNeed;\n            var r = utf8CheckExtraBytes(this, buf, p);\n            if (r !== undefined) return r;\n\n            if (this.lastNeed <= buf.length) {\n              buf.copy(this.lastChar, p, 0, this.lastNeed);\n              return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n            }\n\n            buf.copy(this.lastChar, p, 0, buf.length);\n            this.lastNeed -= buf.length;\n          } // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n          // partial character, the character's bytes are buffered until the required\n          // number of bytes are available.\n\n\n          function utf8Text(buf, i) {\n            var total = utf8CheckIncomplete(this, buf, i);\n            if (!this.lastNeed) return buf.toString('utf8', i);\n            this.lastTotal = total;\n            var end = buf.length - (total - this.lastNeed);\n            buf.copy(this.lastChar, 0, end);\n            return buf.toString('utf8', i, end);\n          } // For UTF-8, a replacement character is added when ending on a partial\n          // character.\n\n\n          function utf8End(buf) {\n            var r = buf && buf.length ? this.write(buf) : '';\n            if (this.lastNeed) return r + '\\ufffd';\n            return r;\n          } // UTF-16LE typically needs two bytes per character, but even if we have an even\n          // number of bytes available, we need to check if we end on a leading/high\n          // surrogate. In that case, we need to wait for the next two bytes in order to\n          // decode the last character properly.\n\n\n          function utf16Text(buf, i) {\n            if ((buf.length - i) % 2 === 0) {\n              var r = buf.toString('utf16le', i);\n\n              if (r) {\n                var c = r.charCodeAt(r.length - 1);\n\n                if (c >= 0xD800 && c <= 0xDBFF) {\n                  this.lastNeed = 2;\n                  this.lastTotal = 4;\n                  this.lastChar[0] = buf[buf.length - 2];\n                  this.lastChar[1] = buf[buf.length - 1];\n                  return r.slice(0, -1);\n                }\n              }\n\n              return r;\n            }\n\n            this.lastNeed = 1;\n            this.lastTotal = 2;\n            this.lastChar[0] = buf[buf.length - 1];\n            return buf.toString('utf16le', i, buf.length - 1);\n          } // For UTF-16LE we do not explicitly append special replacement characters if we\n          // end on a partial character, we simply let v8 handle that.\n\n\n          function utf16End(buf) {\n            var r = buf && buf.length ? this.write(buf) : '';\n\n            if (this.lastNeed) {\n              var end = this.lastTotal - this.lastNeed;\n              return r + this.lastChar.toString('utf16le', 0, end);\n            }\n\n            return r;\n          }\n\n          function base64Text(buf, i) {\n            var n = (buf.length - i) % 3;\n            if (n === 0) return buf.toString('base64', i);\n            this.lastNeed = 3 - n;\n            this.lastTotal = 3;\n\n            if (n === 1) {\n              this.lastChar[0] = buf[buf.length - 1];\n            } else {\n              this.lastChar[0] = buf[buf.length - 2];\n              this.lastChar[1] = buf[buf.length - 1];\n            }\n\n            return buf.toString('base64', i, buf.length - n);\n          }\n\n          function base64End(buf) {\n            var r = buf && buf.length ? this.write(buf) : '';\n            if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n            return r;\n          } // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\n\n\n          function simpleWrite(buf) {\n            return buf.toString(this.encoding);\n          }\n\n          function simpleEnd(buf) {\n            return buf && buf.length ? this.write(buf) : '';\n          }\n          /***/\n\n        },\n\n        /***/\n        511:\n        /***/\n        function (module, exports, __nested_webpack_require_290916__) {\n          /* module decorator */\n          module = __nested_webpack_require_290916__.nmd(module);\n\n          var __WEBPACK_AMD_DEFINE_RESULT__;\n          /*! https://mths.be/punycode v1.3.2 by @mathias */\n\n\n          ;\n\n          (function (root) {\n            /** Detect free variables */\n            var freeExports =  true && exports && !exports.nodeType && exports;\n            var freeModule =  true && module && !module.nodeType && module;\n            var freeGlobal = typeof __nested_webpack_require_290916__.g == 'object' && __nested_webpack_require_290916__.g;\n\n            if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {\n              root = freeGlobal;\n            }\n            /**\n             * The `punycode` object.\n             * @name punycode\n             * @type Object\n             */\n\n\n            var punycode,\n\n            /** Highest positive signed 32-bit float value */\n            maxInt = 2147483647,\n                // aka. 0x7FFFFFFF or 2^31-1\n\n            /** Bootstring parameters */\n            base = 36,\n                tMin = 1,\n                tMax = 26,\n                skew = 38,\n                damp = 700,\n                initialBias = 72,\n                initialN = 128,\n                // 0x80\n            delimiter = '-',\n                // '\\x2D'\n\n            /** Regular expressions */\n            regexPunycode = /^xn--/,\n                regexNonASCII = /[^\\x20-\\x7E]/,\n                // unprintable ASCII chars + non-ASCII chars\n            regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g,\n                // RFC 3490 separators\n\n            /** Error messages */\n            errors = {\n              'overflow': 'Overflow: input needs wider integers to process',\n              'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n              'invalid-input': 'Invalid input'\n            },\n\n            /** Convenience shortcuts */\n            baseMinusTMin = base - tMin,\n                floor = Math.floor,\n                stringFromCharCode = String.fromCharCode,\n\n            /** Temporary variable */\n            key;\n            /*--------------------------------------------------------------------------*/\n\n            /**\n             * A generic error utility function.\n             * @private\n             * @param {String} type The error type.\n             * @returns {Error} Throws a `RangeError` with the applicable error message.\n             */\n\n            function error(type) {\n              throw RangeError(errors[type]);\n            }\n            /**\n             * A generic `Array#map` utility function.\n             * @private\n             * @param {Array} array The array to iterate over.\n             * @param {Function} callback The function that gets called for every array\n             * item.\n             * @returns {Array} A new array of values returned by the callback function.\n             */\n\n\n            function map(array, fn) {\n              var length = array.length;\n              var result = [];\n\n              while (length--) {\n                result[length] = fn(array[length]);\n              }\n\n              return result;\n            }\n            /**\n             * A simple `Array#map`-like wrapper to work with domain name strings or email\n             * addresses.\n             * @private\n             * @param {String} domain The domain name or email address.\n             * @param {Function} callback The function that gets called for every\n             * character.\n             * @returns {Array} A new string of characters returned by the callback\n             * function.\n             */\n\n\n            function mapDomain(string, fn) {\n              var parts = string.split('@');\n              var result = '';\n\n              if (parts.length > 1) {\n                // In email addresses, only the domain name should be punycoded. Leave\n                // the local part (i.e. everything up to `@`) intact.\n                result = parts[0] + '@';\n                string = parts[1];\n              } // Avoid `split(regex)` for IE8 compatibility. See #17.\n\n\n              string = string.replace(regexSeparators, '\\x2E');\n              var labels = string.split('.');\n              var encoded = map(labels, fn).join('.');\n              return result + encoded;\n            }\n            /**\n             * Creates an array containing the numeric code points of each Unicode\n             * character in the string. While JavaScript uses UCS-2 internally,\n             * this function will convert a pair of surrogate halves (each of which\n             * UCS-2 exposes as separate characters) into a single code point,\n             * matching UTF-16.\n             * @see `punycode.ucs2.encode`\n             * @see <https://mathiasbynens.be/notes/javascript-encoding>\n             * @memberOf punycode.ucs2\n             * @name decode\n             * @param {String} string The Unicode input string (UCS-2).\n             * @returns {Array} The new array of code points.\n             */\n\n\n            function ucs2decode(string) {\n              var output = [],\n                  counter = 0,\n                  length = string.length,\n                  value,\n                  extra;\n\n              while (counter < length) {\n                value = string.charCodeAt(counter++);\n\n                if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n                  // high surrogate, and there is a next character\n                  extra = string.charCodeAt(counter++);\n\n                  if ((extra & 0xFC00) == 0xDC00) {\n                    // low surrogate\n                    output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n                  } else {\n                    // unmatched surrogate; only append this code unit, in case the next\n                    // code unit is the high surrogate of a surrogate pair\n                    output.push(value);\n                    counter--;\n                  }\n                } else {\n                  output.push(value);\n                }\n              }\n\n              return output;\n            }\n            /**\n             * Creates a string based on an array of numeric code points.\n             * @see `punycode.ucs2.decode`\n             * @memberOf punycode.ucs2\n             * @name encode\n             * @param {Array} codePoints The array of numeric code points.\n             * @returns {String} The new Unicode string (UCS-2).\n             */\n\n\n            function ucs2encode(array) {\n              return map(array, function (value) {\n                var output = '';\n\n                if (value > 0xFFFF) {\n                  value -= 0x10000;\n                  output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n                  value = 0xDC00 | value & 0x3FF;\n                }\n\n                output += stringFromCharCode(value);\n                return output;\n              }).join('');\n            }\n            /**\n             * Converts a basic code point into a digit/integer.\n             * @see `digitToBasic()`\n             * @private\n             * @param {Number} codePoint The basic numeric code point value.\n             * @returns {Number} The numeric value of a basic code point (for use in\n             * representing integers) in the range `0` to `base - 1`, or `base` if\n             * the code point does not represent a value.\n             */\n\n\n            function basicToDigit(codePoint) {\n              if (codePoint - 48 < 10) {\n                return codePoint - 22;\n              }\n\n              if (codePoint - 65 < 26) {\n                return codePoint - 65;\n              }\n\n              if (codePoint - 97 < 26) {\n                return codePoint - 97;\n              }\n\n              return base;\n            }\n            /**\n             * Converts a digit/integer into a basic code point.\n             * @see `basicToDigit()`\n             * @private\n             * @param {Number} digit The numeric value of a basic code point.\n             * @returns {Number} The basic code point whose value (when used for\n             * representing integers) is `digit`, which needs to be in the range\n             * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n             * used; else, the lowercase form is used. The behavior is undefined\n             * if `flag` is non-zero and `digit` has no uppercase form.\n             */\n\n\n            function digitToBasic(digit, flag) {\n              //  0..25 map to ASCII a..z or A..Z\n              // 26..35 map to ASCII 0..9\n              return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n            }\n            /**\n             * Bias adaptation function as per section 3.4 of RFC 3492.\n             * http://tools.ietf.org/html/rfc3492#section-3.4\n             * @private\n             */\n\n\n            function adapt(delta, numPoints, firstTime) {\n              var k = 0;\n              delta = firstTime ? floor(delta / damp) : delta >> 1;\n              delta += floor(delta / numPoints);\n\n              for (;\n              /* no initialization */\n              delta > baseMinusTMin * tMax >> 1; k += base) {\n                delta = floor(delta / baseMinusTMin);\n              }\n\n              return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n            }\n            /**\n             * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n             * symbols.\n             * @memberOf punycode\n             * @param {String} input The Punycode string of ASCII-only symbols.\n             * @returns {String} The resulting string of Unicode symbols.\n             */\n\n\n            function decode(input) {\n              // Don't use UCS-2\n              var output = [],\n                  inputLength = input.length,\n                  out,\n                  i = 0,\n                  n = initialN,\n                  bias = initialBias,\n                  basic,\n                  j,\n                  index,\n                  oldi,\n                  w,\n                  k,\n                  digit,\n                  t,\n\n              /** Cached calculation results */\n              baseMinusT; // Handle the basic code points: let `basic` be the number of input code\n              // points before the last delimiter, or `0` if there is none, then copy\n              // the first basic code points to the output.\n\n              basic = input.lastIndexOf(delimiter);\n\n              if (basic < 0) {\n                basic = 0;\n              }\n\n              for (j = 0; j < basic; ++j) {\n                // if it's not a basic code point\n                if (input.charCodeAt(j) >= 0x80) {\n                  error('not-basic');\n                }\n\n                output.push(input.charCodeAt(j));\n              } // Main decoding loop: start just after the last delimiter if any basic code\n              // points were copied; start at the beginning otherwise.\n\n\n              for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)\n              /* no final expression */\n              {\n                // `index` is the index of the next character to be consumed.\n                // Decode a generalized variable-length integer into `delta`,\n                // which gets added to `i`. The overflow checking is easier\n                // if we increase `i` as we go, then subtract off its starting\n                // value at the end to obtain `delta`.\n                for (oldi = i, w = 1, k = base;;\n                /* no condition */\n                k += base) {\n                  if (index >= inputLength) {\n                    error('invalid-input');\n                  }\n\n                  digit = basicToDigit(input.charCodeAt(index++));\n\n                  if (digit >= base || digit > floor((maxInt - i) / w)) {\n                    error('overflow');\n                  }\n\n                  i += digit * w;\n                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                  if (digit < t) {\n                    break;\n                  }\n\n                  baseMinusT = base - t;\n\n                  if (w > floor(maxInt / baseMinusT)) {\n                    error('overflow');\n                  }\n\n                  w *= baseMinusT;\n                }\n\n                out = output.length + 1;\n                bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,\n                // incrementing `n` each time, so we'll fix that now:\n\n                if (floor(i / out) > maxInt - n) {\n                  error('overflow');\n                }\n\n                n += floor(i / out);\n                i %= out; // Insert `n` at position `i` of the output\n\n                output.splice(i++, 0, n);\n              }\n\n              return ucs2encode(output);\n            }\n            /**\n             * Converts a string of Unicode symbols (e.g. a domain name label) to a\n             * Punycode string of ASCII-only symbols.\n             * @memberOf punycode\n             * @param {String} input The string of Unicode symbols.\n             * @returns {String} The resulting Punycode string of ASCII-only symbols.\n             */\n\n\n            function encode(input) {\n              var n,\n                  delta,\n                  handledCPCount,\n                  basicLength,\n                  bias,\n                  j,\n                  m,\n                  q,\n                  k,\n                  t,\n                  currentValue,\n                  output = [],\n\n              /** `inputLength` will hold the number of code points in `input`. */\n              inputLength,\n\n              /** Cached calculation results */\n              handledCPCountPlusOne,\n                  baseMinusT,\n                  qMinusT; // Convert the input in UCS-2 to Unicode\n\n              input = ucs2decode(input); // Cache the length\n\n              inputLength = input.length; // Initialize the state\n\n              n = initialN;\n              delta = 0;\n              bias = initialBias; // Handle the basic code points\n\n              for (j = 0; j < inputLength; ++j) {\n                currentValue = input[j];\n\n                if (currentValue < 0x80) {\n                  output.push(stringFromCharCode(currentValue));\n                }\n              }\n\n              handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;\n              // `basicLength` is the number of basic code points.\n              // Finish the basic string - if it is not empty - with a delimiter\n\n              if (basicLength) {\n                output.push(delimiter);\n              } // Main encoding loop:\n\n\n              while (handledCPCount < inputLength) {\n                // All non-basic code points < n have been handled already. Find the next\n                // larger one:\n                for (m = maxInt, j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue >= n && currentValue < m) {\n                    m = currentValue;\n                  }\n                } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n                // but guard against overflow\n\n\n                handledCPCountPlusOne = handledCPCount + 1;\n\n                if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n                  error('overflow');\n                }\n\n                delta += (m - n) * handledCPCountPlusOne;\n                n = m;\n\n                for (j = 0; j < inputLength; ++j) {\n                  currentValue = input[j];\n\n                  if (currentValue < n && ++delta > maxInt) {\n                    error('overflow');\n                  }\n\n                  if (currentValue == n) {\n                    // Represent delta as a generalized variable-length integer\n                    for (q = delta, k = base;;\n                    /* no condition */\n                    k += base) {\n                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n                      if (q < t) {\n                        break;\n                      }\n\n                      qMinusT = q - t;\n                      baseMinusT = base - t;\n                      output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n                      q = floor(qMinusT / baseMinusT);\n                    }\n\n                    output.push(stringFromCharCode(digitToBasic(q, 0)));\n                    bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n                    delta = 0;\n                    ++handledCPCount;\n                  }\n                }\n\n                ++delta;\n                ++n;\n              }\n\n              return output.join('');\n            }\n            /**\n             * Converts a Punycode string representing a domain name or an email address\n             * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n             * it doesn't matter if you call it on a string that has already been\n             * converted to Unicode.\n             * @memberOf punycode\n             * @param {String} input The Punycoded domain name or email address to\n             * convert to Unicode.\n             * @returns {String} The Unicode representation of the given Punycode\n             * string.\n             */\n\n\n            function toUnicode(input) {\n              return mapDomain(input, function (string) {\n                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n              });\n            }\n            /**\n             * Converts a Unicode string representing a domain name or an email address to\n             * Punycode. Only the non-ASCII parts of the domain name will be converted,\n             * i.e. it doesn't matter if you call it with a domain that's already in\n             * ASCII.\n             * @memberOf punycode\n             * @param {String} input The domain name or email address to convert, as a\n             * Unicode string.\n             * @returns {String} The Punycode representation of the given domain name or\n             * email address.\n             */\n\n\n            function toASCII(input) {\n              return mapDomain(input, function (string) {\n                return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n              });\n            }\n            /*--------------------------------------------------------------------------*/\n\n            /** Define the public API */\n\n\n            punycode = {\n              /**\n               * A string representing the current Punycode.js version number.\n               * @memberOf punycode\n               * @type String\n               */\n              'version': '1.3.2',\n\n              /**\n               * An object of methods to convert from JavaScript's internal character\n               * representation (UCS-2) to Unicode code points, and back.\n               * @see <https://mathiasbynens.be/notes/javascript-encoding>\n               * @memberOf punycode\n               * @type Object\n               */\n              'ucs2': {\n                'decode': ucs2decode,\n                'encode': ucs2encode\n              },\n              'decode': decode,\n              'encode': encode,\n              'toASCII': toASCII,\n              'toUnicode': toUnicode\n            };\n            /** Expose `punycode` */\n            // Some AMD build optimizers, like r.js, check for specific condition patterns\n            // like the following:\n\n            if (true) {\n              !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {\n                return punycode;\n              }.call(exports, __nested_webpack_require_290916__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n            } else {}\n          })(this);\n          /***/\n\n        },\n\n        /***/\n        575:\n        /***/\n        (__unused_webpack_module, exports, __nested_webpack_require_310960__) => {\n          \"use strict\"; // Copyright Joyent, Inc. and other Node contributors.\n          //\n          // Permission is hereby granted, free of charge, to any person obtaining a\n          // copy of this software and associated documentation files (the\n          // \"Software\"), to deal in the Software without restriction, including\n          // without limitation the rights to use, copy, modify, merge, publish,\n          // distribute, sublicense, and/or sell copies of the Software, and to permit\n          // persons to whom the Software is furnished to do so, subject to the\n          // following conditions:\n          //\n          // The above copyright notice and this permission notice shall be included\n          // in all copies or substantial portions of the Software.\n          //\n          // THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n          // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n          // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n          // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n          // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n          // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n          // USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n          var punycode = __nested_webpack_require_310960__(511);\n\n          var util = __nested_webpack_require_310960__(502);\n\n          exports.parse = urlParse;\n          exports.resolve = urlResolve;\n          exports.resolveObject = urlResolveObject;\n          exports.format = urlFormat;\n          exports.Url = Url;\n\n          function Url() {\n            this.protocol = null;\n            this.slashes = null;\n            this.auth = null;\n            this.host = null;\n            this.port = null;\n            this.hostname = null;\n            this.hash = null;\n            this.search = null;\n            this.query = null;\n            this.pathname = null;\n            this.path = null;\n            this.href = null;\n          } // Reference: RFC 3986, RFC 1808, RFC 2396\n          // define these here so at least they only have to be\n          // compiled once on the first module load.\n\n\n          var protocolPattern = /^([a-z0-9.+-]+:)/i,\n              portPattern = /:[0-9]*$/,\n              // Special case for a simple path URL\n          simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n              // RFC 2396: characters reserved for delimiting URLs.\n          // We actually just auto-escape these.\n          delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n              // RFC 2396: characters not allowed for various reasons.\n          unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n              // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n          autoEscape = ['\\''].concat(unwise),\n              // Characters that are never ever allowed in a hostname.\n          // Note that any invalid chars are also handled, but these\n          // are the ones that are *expected* to be seen, so we fast-path\n          // them.\n          nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n              hostEndingChars = ['/', '?', '#'],\n              hostnameMaxLen = 255,\n              hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n              hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n              // protocols that can allow \"unsafe\" and \"unwise\" chars.\n          unsafeProtocol = {\n            'javascript': true,\n            'javascript:': true\n          },\n              // protocols that never have a hostname.\n          hostlessProtocol = {\n            'javascript': true,\n            'javascript:': true\n          },\n              // protocols that always contain a // bit.\n          slashedProtocol = {\n            'http': true,\n            'https': true,\n            'ftp': true,\n            'gopher': true,\n            'file': true,\n            'http:': true,\n            'https:': true,\n            'ftp:': true,\n            'gopher:': true,\n            'file:': true\n          },\n              querystring = __nested_webpack_require_310960__(673);\n\n          function urlParse(url, parseQueryString, slashesDenoteHost) {\n            if (url && util.isObject(url) && url instanceof Url) return url;\n            var u = new Url();\n            u.parse(url, parseQueryString, slashesDenoteHost);\n            return u;\n          }\n\n          Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {\n            if (!util.isString(url)) {\n              throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n            } // Copy chrome, IE, opera backslash-handling behavior.\n            // Back slashes before the query string get converted to forward slashes\n            // See: https://code.google.com/p/chromium/issues/detail?id=25916\n\n\n            var queryIndex = url.indexOf('?'),\n                splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',\n                uSplit = url.split(splitter),\n                slashRegex = /\\\\/g;\n            uSplit[0] = uSplit[0].replace(slashRegex, '/');\n            url = uSplit.join(splitter);\n            var rest = url; // trim before proceeding.\n            // This is to support parse stuff like \"  http://foo.com  \\n\"\n\n            rest = rest.trim();\n\n            if (!slashesDenoteHost && url.split('#').length === 1) {\n              // Try fast path regexp\n              var simplePath = simplePathPattern.exec(rest);\n\n              if (simplePath) {\n                this.path = rest;\n                this.href = rest;\n                this.pathname = simplePath[1];\n\n                if (simplePath[2]) {\n                  this.search = simplePath[2];\n\n                  if (parseQueryString) {\n                    this.query = querystring.parse(this.search.substr(1));\n                  } else {\n                    this.query = this.search.substr(1);\n                  }\n                } else if (parseQueryString) {\n                  this.search = '';\n                  this.query = {};\n                }\n\n                return this;\n              }\n            }\n\n            var proto = protocolPattern.exec(rest);\n\n            if (proto) {\n              proto = proto[0];\n              var lowerProto = proto.toLowerCase();\n              this.protocol = lowerProto;\n              rest = rest.substr(proto.length);\n            } // figure out if it's got a host\n            // user@server is *always* interpreted as a hostname, and url\n            // resolution will treat //foo/bar as host=foo,path=bar because that's\n            // how the browser resolves relative URLs.\n\n\n            if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n              var slashes = rest.substr(0, 2) === '//';\n\n              if (slashes && !(proto && hostlessProtocol[proto])) {\n                rest = rest.substr(2);\n                this.slashes = true;\n              }\n            }\n\n            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {\n              // there's a hostname.\n              // the first instance of /, ?, ;, or # ends the host.\n              //\n              // If there is an @ in the hostname, then non-host chars *are* allowed\n              // to the left of the last @ sign, unless some host-ending character\n              // comes *before* the @-sign.\n              // URLs are obnoxious.\n              //\n              // ex:\n              // http://a@b@c/ => user:a@b host:c\n              // http://a@b?@c => user:a host:c path:/?@c\n              // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n              // Review our test case against browsers more comprehensively.\n              // find the first instance of any hostEndingChars\n              var hostEnd = -1;\n\n              for (var i = 0; i < hostEndingChars.length; i++) {\n                var hec = rest.indexOf(hostEndingChars[i]);\n                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n              } // at this point, either we have an explicit point where the\n              // auth portion cannot go past, or the last @ char is the decider.\n\n\n              var auth, atSign;\n\n              if (hostEnd === -1) {\n                // atSign can be anywhere.\n                atSign = rest.lastIndexOf('@');\n              } else {\n                // atSign must be in auth portion.\n                // http://a@b/c@d => host:b auth:a path:/c@d\n                atSign = rest.lastIndexOf('@', hostEnd);\n              } // Now we have a portion which is definitely the auth.\n              // Pull that off.\n\n\n              if (atSign !== -1) {\n                auth = rest.slice(0, atSign);\n                rest = rest.slice(atSign + 1);\n                this.auth = decodeURIComponent(auth);\n              } // the host is the remaining to the left of the first non-host char\n\n\n              hostEnd = -1;\n\n              for (var i = 0; i < nonHostChars.length; i++) {\n                var hec = rest.indexOf(nonHostChars[i]);\n                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;\n              } // if we still have not hit it, then the entire thing is a host.\n\n\n              if (hostEnd === -1) hostEnd = rest.length;\n              this.host = rest.slice(0, hostEnd);\n              rest = rest.slice(hostEnd); // pull out port.\n\n              this.parseHost(); // we've indicated that there is a hostname,\n              // so even if it's empty, it has to be present.\n\n              this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]\n              // assume that it's an IPv6 address.\n\n              var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.\n\n              if (!ipv6Hostname) {\n                var hostparts = this.hostname.split(/\\./);\n\n                for (var i = 0, l = hostparts.length; i < l; i++) {\n                  var part = hostparts[i];\n                  if (!part) continue;\n\n                  if (!part.match(hostnamePartPattern)) {\n                    var newpart = '';\n\n                    for (var j = 0, k = part.length; j < k; j++) {\n                      if (part.charCodeAt(j) > 127) {\n                        // we replace non-ASCII char with a temporary placeholder\n                        // we need this to make sure size of hostname is not\n                        // broken by replacing non-ASCII by nothing\n                        newpart += 'x';\n                      } else {\n                        newpart += part[j];\n                      }\n                    } // we test again with ASCII char only\n\n\n                    if (!newpart.match(hostnamePartPattern)) {\n                      var validParts = hostparts.slice(0, i);\n                      var notHost = hostparts.slice(i + 1);\n                      var bit = part.match(hostnamePartStart);\n\n                      if (bit) {\n                        validParts.push(bit[1]);\n                        notHost.unshift(bit[2]);\n                      }\n\n                      if (notHost.length) {\n                        rest = '/' + notHost.join('.') + rest;\n                      }\n\n                      this.hostname = validParts.join('.');\n                      break;\n                    }\n                  }\n                }\n              }\n\n              if (this.hostname.length > hostnameMaxLen) {\n                this.hostname = '';\n              } else {\n                // hostnames are always lower case.\n                this.hostname = this.hostname.toLowerCase();\n              }\n\n              if (!ipv6Hostname) {\n                // IDNA Support: Returns a punycoded representation of \"domain\".\n                // It only converts parts of the domain name that\n                // have non-ASCII characters, i.e. it doesn't matter if\n                // you call it with a domain that already is ASCII-only.\n                this.hostname = punycode.toASCII(this.hostname);\n              }\n\n              var p = this.port ? ':' + this.port : '';\n              var h = this.hostname || '';\n              this.host = h + p;\n              this.href += this.host; // strip [ and ] from the hostname\n              // the host field still retains them, though\n\n              if (ipv6Hostname) {\n                this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n\n                if (rest[0] !== '/') {\n                  rest = '/' + rest;\n                }\n              }\n            } // now rest is set to the post-host stuff.\n            // chop off any delim chars.\n\n\n            if (!unsafeProtocol[lowerProto]) {\n              // First, make 100% sure that any \"autoEscape\" chars get\n              // escaped, even if encodeURIComponent doesn't think they\n              // need to be.\n              for (var i = 0, l = autoEscape.length; i < l; i++) {\n                var ae = autoEscape[i];\n                if (rest.indexOf(ae) === -1) continue;\n                var esc = encodeURIComponent(ae);\n\n                if (esc === ae) {\n                  esc = escape(ae);\n                }\n\n                rest = rest.split(ae).join(esc);\n              }\n            } // chop off from the tail first.\n\n\n            var hash = rest.indexOf('#');\n\n            if (hash !== -1) {\n              // got a fragment string.\n              this.hash = rest.substr(hash);\n              rest = rest.slice(0, hash);\n            }\n\n            var qm = rest.indexOf('?');\n\n            if (qm !== -1) {\n              this.search = rest.substr(qm);\n              this.query = rest.substr(qm + 1);\n\n              if (parseQueryString) {\n                this.query = querystring.parse(this.query);\n              }\n\n              rest = rest.slice(0, qm);\n            } else if (parseQueryString) {\n              // no query string, but parseQueryString still requested\n              this.search = '';\n              this.query = {};\n            }\n\n            if (rest) this.pathname = rest;\n\n            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {\n              this.pathname = '/';\n            } //to support http.request\n\n\n            if (this.pathname || this.search) {\n              var p = this.pathname || '';\n              var s = this.search || '';\n              this.path = p + s;\n            } // finally, reconstruct the href based on what has been validated.\n\n\n            this.href = this.format();\n            return this;\n          }; // format a parsed object into a url string\n\n\n          function urlFormat(obj) {\n            // ensure it's an object, and not a string url.\n            // If it's an obj, this is a no-op.\n            // this way, you can call url_format() on strings\n            // to clean up potentially wonky urls.\n            if (util.isString(obj)) obj = urlParse(obj);\n            if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n            return obj.format();\n          }\n\n          Url.prototype.format = function () {\n            var auth = this.auth || '';\n\n            if (auth) {\n              auth = encodeURIComponent(auth);\n              auth = auth.replace(/%3A/i, ':');\n              auth += '@';\n            }\n\n            var protocol = this.protocol || '',\n                pathname = this.pathname || '',\n                hash = this.hash || '',\n                host = false,\n                query = '';\n\n            if (this.host) {\n              host = auth + this.host;\n            } else if (this.hostname) {\n              host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');\n\n              if (this.port) {\n                host += ':' + this.port;\n              }\n            }\n\n            if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {\n              query = querystring.stringify(this.query);\n            }\n\n            var search = this.search || query && '?' + query || '';\n            if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n            // unless they had them to begin with.\n\n            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {\n              host = '//' + (host || '');\n              if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n            } else if (!host) {\n              host = '';\n            }\n\n            if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n            if (search && search.charAt(0) !== '?') search = '?' + search;\n            pathname = pathname.replace(/[?#]/g, function (match) {\n              return encodeURIComponent(match);\n            });\n            search = search.replace('#', '%23');\n            return protocol + host + pathname + search + hash;\n          };\n\n          function urlResolve(source, relative) {\n            return urlParse(source, false, true).resolve(relative);\n          }\n\n          Url.prototype.resolve = function (relative) {\n            return this.resolveObject(urlParse(relative, false, true)).format();\n          };\n\n          function urlResolveObject(source, relative) {\n            if (!source) return relative;\n            return urlParse(source, false, true).resolveObject(relative);\n          }\n\n          Url.prototype.resolveObject = function (relative) {\n            if (util.isString(relative)) {\n              var rel = new Url();\n              rel.parse(relative, false, true);\n              relative = rel;\n            }\n\n            var result = new Url();\n            var tkeys = Object.keys(this);\n\n            for (var tk = 0; tk < tkeys.length; tk++) {\n              var tkey = tkeys[tk];\n              result[tkey] = this[tkey];\n            } // hash is always overridden, no matter what.\n            // even href=\"\" will remove it.\n\n\n            result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.\n\n            if (relative.href === '') {\n              result.href = result.format();\n              return result;\n            } // hrefs like //foo/bar always cut to the protocol.\n\n\n            if (relative.slashes && !relative.protocol) {\n              // take everything except the protocol from relative\n              var rkeys = Object.keys(relative);\n\n              for (var rk = 0; rk < rkeys.length; rk++) {\n                var rkey = rkeys[rk];\n                if (rkey !== 'protocol') result[rkey] = relative[rkey];\n              } //urlParse appends trailing / to urls like http://www.example.com\n\n\n              if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {\n                result.path = result.pathname = '/';\n              }\n\n              result.href = result.format();\n              return result;\n            }\n\n            if (relative.protocol && relative.protocol !== result.protocol) {\n              // if it's a known url protocol, then changing\n              // the protocol does weird things\n              // first, if it's not file:, then we MUST have a host,\n              // and if there was a path\n              // to begin with, then we MUST have a path.\n              // if it is file:, then the host is dropped,\n              // because that's known to be hostless.\n              // anything else is assumed to be absolute.\n              if (!slashedProtocol[relative.protocol]) {\n                var keys = Object.keys(relative);\n\n                for (var v = 0; v < keys.length; v++) {\n                  var k = keys[v];\n                  result[k] = relative[k];\n                }\n\n                result.href = result.format();\n                return result;\n              }\n\n              result.protocol = relative.protocol;\n\n              if (!relative.host && !hostlessProtocol[relative.protocol]) {\n                var relPath = (relative.pathname || '').split('/');\n\n                while (relPath.length && !(relative.host = relPath.shift()));\n\n                if (!relative.host) relative.host = '';\n                if (!relative.hostname) relative.hostname = '';\n                if (relPath[0] !== '') relPath.unshift('');\n                if (relPath.length < 2) relPath.unshift('');\n                result.pathname = relPath.join('/');\n              } else {\n                result.pathname = relative.pathname;\n              }\n\n              result.search = relative.search;\n              result.query = relative.query;\n              result.host = relative.host || '';\n              result.auth = relative.auth;\n              result.hostname = relative.hostname || relative.host;\n              result.port = relative.port; // to support http.request\n\n              if (result.pathname || result.search) {\n                var p = result.pathname || '';\n                var s = result.search || '';\n                result.path = p + s;\n              }\n\n              result.slashes = result.slashes || relative.slashes;\n              result.href = result.format();\n              return result;\n            }\n\n            var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',\n                isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',\n                mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,\n                removeAllDots = mustEndAbs,\n                srcPath = result.pathname && result.pathname.split('/') || [],\n                relPath = relative.pathname && relative.pathname.split('/') || [],\n                psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative\n            // links like ../.. should be able\n            // to crawl up to the hostname, as well.  This is strange.\n            // result.protocol has already been set by now.\n            // Later on, put the first path part into the host field.\n\n            if (psychotic) {\n              result.hostname = '';\n              result.port = null;\n\n              if (result.host) {\n                if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);\n              }\n\n              result.host = '';\n\n              if (relative.protocol) {\n                relative.hostname = null;\n                relative.port = null;\n\n                if (relative.host) {\n                  if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);\n                }\n\n                relative.host = null;\n              }\n\n              mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n            }\n\n            if (isRelAbs) {\n              // it's absolute.\n              result.host = relative.host || relative.host === '' ? relative.host : result.host;\n              result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;\n              result.search = relative.search;\n              result.query = relative.query;\n              srcPath = relPath; // fall through to the dot-handling below.\n            } else if (relPath.length) {\n              // it's relative\n              // throw away the existing file, and take the new path instead.\n              if (!srcPath) srcPath = [];\n              srcPath.pop();\n              srcPath = srcPath.concat(relPath);\n              result.search = relative.search;\n              result.query = relative.query;\n            } else if (!util.isNullOrUndefined(relative.search)) {\n              // just pull out the search.\n              // like href='?foo'.\n              // Put this after the other two cases because it simplifies the booleans\n              if (psychotic) {\n                result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host\n                //this especially happens in cases like\n                //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n                var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n                if (authInHost) {\n                  result.auth = authInHost.shift();\n                  result.host = result.hostname = authInHost.shift();\n                }\n              }\n\n              result.search = relative.search;\n              result.query = relative.query; //to support http.request\n\n              if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n                result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n              }\n\n              result.href = result.format();\n              return result;\n            }\n\n            if (!srcPath.length) {\n              // no path at all.  easy.\n              // we've already handled the other stuff above.\n              result.pathname = null; //to support http.request\n\n              if (result.search) {\n                result.path = '/' + result.search;\n              } else {\n                result.path = null;\n              }\n\n              result.href = result.format();\n              return result;\n            } // if a url ENDs in . or .., then it must get a trailing slash.\n            // however, if it ends in anything else non-slashy,\n            // then it must NOT get a trailing slash.\n\n\n            var last = srcPath.slice(-1)[0];\n            var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir\n            // if the path tries to go above the root, `up` ends up > 0\n\n            var up = 0;\n\n            for (var i = srcPath.length; i >= 0; i--) {\n              last = srcPath[i];\n\n              if (last === '.') {\n                srcPath.splice(i, 1);\n              } else if (last === '..') {\n                srcPath.splice(i, 1);\n                up++;\n              } else if (up) {\n                srcPath.splice(i, 1);\n                up--;\n              }\n            } // if the path is allowed to go above the root, restore leading ..s\n\n\n            if (!mustEndAbs && !removeAllDots) {\n              for (; up--; up) {\n                srcPath.unshift('..');\n              }\n            }\n\n            if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n              srcPath.unshift('');\n            }\n\n            if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {\n              srcPath.push('');\n            }\n\n            var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back\n\n            if (psychotic) {\n              result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host\n              //this especially happens in cases like\n              //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n\n              var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;\n\n              if (authInHost) {\n                result.auth = authInHost.shift();\n                result.host = result.hostname = authInHost.shift();\n              }\n            }\n\n            mustEndAbs = mustEndAbs || result.host && srcPath.length;\n\n            if (mustEndAbs && !isAbsolute) {\n              srcPath.unshift('');\n            }\n\n            if (!srcPath.length) {\n              result.pathname = null;\n              result.path = null;\n            } else {\n              result.pathname = srcPath.join('/');\n            } //to support request.http\n\n\n            if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n              result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n            }\n\n            result.auth = relative.auth || result.auth;\n            result.slashes = result.slashes || relative.slashes;\n            result.href = result.format();\n            return result;\n          };\n\n          Url.prototype.parseHost = function () {\n            var host = this.host;\n            var port = portPattern.exec(host);\n\n            if (port) {\n              port = port[0];\n\n              if (port !== ':') {\n                this.port = port.substr(1);\n              }\n\n              host = host.substr(0, host.length - port.length);\n            }\n\n            if (host) this.hostname = host;\n          };\n          /***/\n\n        },\n\n        /***/\n        502:\n        /***/\n        module => {\n          \"use strict\";\n\n          module.exports = {\n            isString: function (arg) {\n              return typeof arg === 'string';\n            },\n            isObject: function (arg) {\n              return typeof arg === 'object' && arg !== null;\n            },\n            isNull: function (arg) {\n              return arg === null;\n            },\n            isNullOrUndefined: function (arg) {\n              return arg == null;\n            }\n          };\n          /***/\n        },\n\n        /***/\n        927:\n        /***/\n        (module, __unused_webpack_exports, __nested_webpack_require_340265__) => {\n          /**\n           * Module exports.\n           */\n          module.exports = deprecate;\n          /**\n           * Mark that a method should not be used.\n           * Returns a modified function which warns once by default.\n           *\n           * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n           *\n           * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n           * will throw an Error when invoked.\n           *\n           * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n           * will invoke `console.trace()` instead of `console.error()`.\n           *\n           * @param {Function} fn - the function to deprecate\n           * @param {String} msg - the string to print to the console when `fn` is invoked\n           * @returns {Function} a new \"deprecated\" version of `fn`\n           * @api public\n           */\n\n          function deprecate(fn, msg) {\n            if (config('noDeprecation')) {\n              return fn;\n            }\n\n            var warned = false;\n\n            function deprecated() {\n              if (!warned) {\n                if (config('throwDeprecation')) {\n                  throw new Error(msg);\n                } else if (config('traceDeprecation')) {\n                  console.trace(msg);\n                } else {\n                  console.warn(msg);\n                }\n\n                warned = true;\n              }\n\n              return fn.apply(this, arguments);\n            }\n\n            return deprecated;\n          }\n          /**\n           * Checks `localStorage` for boolean values for the given `name`.\n           *\n           * @param {String} name\n           * @returns {Boolean}\n           * @api private\n           */\n\n\n          function config(name) {\n            // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n            try {\n              if (!__nested_webpack_require_340265__.g.localStorage) return false;\n            } catch (_) {\n              return false;\n            }\n\n            var val = __nested_webpack_require_340265__.g.localStorage[name];\n            if (null == val) return false;\n            return String(val).toLowerCase() === 'true';\n          }\n          /***/\n\n        },\n\n        /***/\n        529:\n        /***/\n        module => {\n          module.exports = extend;\n          var hasOwnProperty = Object.prototype.hasOwnProperty;\n\n          function extend() {\n            var target = {};\n\n            for (var i = 0; i < arguments.length; i++) {\n              var source = arguments[i];\n\n              for (var key in source) {\n                if (hasOwnProperty.call(source, key)) {\n                  target[key] = source[key];\n                }\n              }\n            }\n\n            return target;\n          }\n          /***/\n\n        },\n\n        /***/\n        758:\n        /***/\n        () => {\n          /* (ignored) */\n\n          /***/\n        }\n        /******/\n\n      };\n      /************************************************************************/\n\n      /******/\n      // The module cache\n\n      /******/\n\n      var __webpack_module_cache__ = {};\n      /******/\n\n      /******/\n      // The require function\n\n      /******/\n\n      function __nested_webpack_require_343533__(moduleId) {\n        /******/\n        // Check if module is in cache\n\n        /******/\n        if (__webpack_module_cache__[moduleId]) {\n          /******/\n          return __webpack_module_cache__[moduleId].exports;\n          /******/\n        }\n        /******/\n        // Create a new module (and put it into the cache)\n\n        /******/\n\n\n        var module = __webpack_module_cache__[moduleId] = {\n          /******/\n          id: moduleId,\n\n          /******/\n          loaded: false,\n\n          /******/\n          exports: {}\n          /******/\n\n        };\n        /******/\n\n        /******/\n        // Execute the module function\n\n        /******/\n\n        __webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_343533__);\n        /******/\n\n        /******/\n        // Flag the module as loaded\n\n        /******/\n\n\n        module.loaded = true;\n        /******/\n\n        /******/\n        // Return the exports of the module\n\n        /******/\n\n        return module.exports;\n        /******/\n      }\n      /******/\n\n      /************************************************************************/\n\n      /******/\n\n      /* webpack/runtime/define property getters */\n\n      /******/\n\n\n      (() => {\n        /******/\n        // define getter functions for harmony exports\n\n        /******/\n        __nested_webpack_require_343533__.d = (exports, definition) => {\n          /******/\n          for (var key in definition) {\n            /******/\n            if (__nested_webpack_require_343533__.o(definition, key) && !__nested_webpack_require_343533__.o(exports, key)) {\n              /******/\n              Object.defineProperty(exports, key, {\n                enumerable: true,\n                get: definition[key]\n              });\n              /******/\n            }\n            /******/\n\n          }\n          /******/\n\n        };\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/global */\n\n      /******/\n\n\n      (() => {\n        /******/\n        __nested_webpack_require_343533__.g = function () {\n          /******/\n          if (typeof globalThis === 'object') return globalThis;\n          /******/\n\n          try {\n            /******/\n            return this || new Function('return this')();\n            /******/\n          } catch (e) {\n            /******/\n            if (typeof window === 'object') return window;\n            /******/\n          }\n          /******/\n\n        }();\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/hasOwnProperty shorthand */\n\n      /******/\n\n\n      (() => {\n        /******/\n        __nested_webpack_require_343533__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\n        /******/\n\n      })();\n      /******/\n\n      /******/\n\n      /* webpack/runtime/node module decorator */\n\n      /******/\n\n\n      (() => {\n        /******/\n        __nested_webpack_require_343533__.nmd = module => {\n          /******/\n          module.paths = [];\n          /******/\n\n          if (!module.children) module.children = [];\n          /******/\n\n          return module;\n          /******/\n        };\n        /******/\n\n      })();\n      /******/\n\n      /************************************************************************/\n\n      /******/\n      // module exports must be returned from runtime so entry inlining is disabled\n\n      /******/\n      // startup\n\n      /******/\n      // Load entry module and return exports\n\n      /******/\n\n\n      return __nested_webpack_require_343533__(328);\n      /******/\n    })().default\n  );\n});\n\n//# sourceURL=webpack://urbit/./dist/browser.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => module['default'] :
/******/ 				() => module;
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop)
/******/ 	})();
/******/ 	
/************************************************************************/
(() => {
"use strict";
/*!********************************!*\
  !*** ./src/example/browser.js ***!
  \********************************/
/*! namespace exports */
/*! runtime requirements: __webpack_require__, __webpack_require__.n, __webpack_require__.* */
eval("/* harmony import */ var _dist_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/browser */ \"./dist/browser.js\");\n/* harmony import */ var _dist_browser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dist_browser__WEBPACK_IMPORTED_MODULE_0__);\n;\nwindow.Urbit = (_dist_browser__WEBPACK_IMPORTED_MODULE_0___default());\n\n//# sourceURL=webpack://urbit/./src/example/browser.js?");
})();

/******/ })()
;